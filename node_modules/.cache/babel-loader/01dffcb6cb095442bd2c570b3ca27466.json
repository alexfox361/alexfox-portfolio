{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\n\nclass Info {\n  constructor() {\n    this.any_blank_count = 0;\n    this.any_blank_ms = 0;\n    this.any_blank_speed_sum = 0;\n    this.mostly_blank_count = 0;\n    this.mostly_blank_ms = 0;\n    this.pixels_blank = 0;\n    this.pixels_sampled = 0;\n    this.pixels_scrolled = 0;\n    this.total_time_spent = 0;\n    this.sample_count = 0;\n  }\n\n}\n\nvar DEBUG = false;\nvar _listeners = [];\nvar _minSampleCount = 10;\n\nvar _sampleRate = DEBUG ? 1 : null;\n/**\n * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.\n * By default the sampling rate is set to zero and this will do nothing. If you want to collect\n * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.\n *\n * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with\n * `SceneTracker.getActiveScene` to determine the context of the events.\n */\n\n\nclass FillRateHelper {\n  static addListener(callback) {\n    if (_sampleRate === null) {\n      console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');\n    }\n\n    _listeners.push(callback);\n\n    return {\n      remove: () => {\n        _listeners = _listeners.filter(listener => callback !== listener);\n      }\n    };\n  }\n\n  static setSampleRate(sampleRate) {\n    _sampleRate = sampleRate;\n  }\n\n  static setMinSampleCount(minSampleCount) {\n    _minSampleCount = minSampleCount;\n  }\n\n  constructor(getFrameMetrics) {\n    this._anyBlankStartTime = null;\n    this._enabled = false;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n    this._getFrameMetrics = getFrameMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n\n    this._resetData();\n  }\n\n  activate() {\n    if (this._enabled && this._samplesStartTime == null) {\n      DEBUG && console.debug('FillRateHelper: activate');\n      this._samplesStartTime = global.performance.now();\n    }\n  }\n\n  deactivateAndFlush() {\n    if (!this._enabled) {\n      return;\n    }\n\n    var start = this._samplesStartTime; // const for flow\n\n    if (start == null) {\n      DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');\n      return;\n    }\n\n    if (this._info.sample_count < _minSampleCount) {\n      // Don't bother with under-sampled events.\n      this._resetData();\n\n      return;\n    }\n\n    var total_time_spent = global.performance.now() - start;\n\n    var info = _objectSpread(_objectSpread({}, this._info), {}, {\n      total_time_spent\n    });\n\n    if (DEBUG) {\n      var derived = {\n        avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n        avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n        avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,\n        any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),\n        any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n        mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n        mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent\n      };\n\n      for (var key in derived) {\n        derived[key] = Math.round(1000 * derived[key]) / 1000;\n      }\n\n      console.debug('FillRateHelper deactivateAndFlush: ', {\n        derived,\n        info\n      });\n    }\n\n    _listeners.forEach(listener => listener(info));\n\n    this._resetData();\n  }\n\n  computeBlankness(props, state, scrollMetrics) {\n    if (!this._enabled || props.getItemCount(props.data) === 0 || this._samplesStartTime == null) {\n      return 0;\n    }\n\n    var dOffset = scrollMetrics.dOffset,\n        offset = scrollMetrics.offset,\n        velocity = scrollMetrics.velocity,\n        visibleLength = scrollMetrics.visibleLength; // Denominator metrics that we track for all events - most of the time there is no blankness and\n    // we want to capture that.\n\n    this._info.sample_count++;\n    this._info.pixels_sampled += Math.round(visibleLength);\n    this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n    var scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec\n    // Whether blank now or not, record the elapsed time blank if we were blank last time.\n\n    var now = global.performance.now();\n\n    if (this._anyBlankStartTime != null) {\n      this._info.any_blank_ms += now - this._anyBlankStartTime;\n    }\n\n    this._anyBlankStartTime = null;\n\n    if (this._mostlyBlankStartTime != null) {\n      this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n    }\n\n    this._mostlyBlankStartTime = null;\n    var blankTop = 0;\n    var first = state.first;\n\n    var firstFrame = this._getFrameMetrics(first);\n\n    while (first <= state.last && (!firstFrame || !firstFrame.inLayout)) {\n      firstFrame = this._getFrameMetrics(first);\n      first++;\n    } // Only count blankTop if we aren't rendering the first item, otherwise we will count the header\n    // as blank.\n\n\n    if (firstFrame && first > 0) {\n      blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));\n    }\n\n    var blankBottom = 0;\n    var last = state.last;\n\n    var lastFrame = this._getFrameMetrics(last);\n\n    while (last >= state.first && (!lastFrame || !lastFrame.inLayout)) {\n      lastFrame = this._getFrameMetrics(last);\n      last--;\n    } // Only count blankBottom if we aren't rendering the last item, otherwise we will count the\n    // footer as blank.\n\n\n    if (lastFrame && last < props.getItemCount(props.data) - 1) {\n      var bottomEdge = lastFrame.offset + lastFrame.length;\n      blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));\n    }\n\n    var pixels_blank = Math.round(blankTop + blankBottom);\n    var blankness = pixels_blank / visibleLength;\n\n    if (blankness > 0) {\n      this._anyBlankStartTime = now;\n      this._info.any_blank_speed_sum += scrollSpeed;\n      this._info.any_blank_count++;\n      this._info.pixels_blank += pixels_blank;\n\n      if (blankness > 0.5) {\n        this._mostlyBlankStartTime = now;\n        this._info.mostly_blank_count++;\n      }\n    } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n      this.deactivateAndFlush();\n    }\n\n    return blankness;\n  }\n\n  enabled() {\n    return this._enabled;\n  }\n\n  _resetData() {\n    this._anyBlankStartTime = null;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n  }\n\n}\n\nexport default FillRateHelper;","map":{"version":3,"sources":["C:/Users/alex/Documents/GitHub/alexfox-portfolio/node_modules/react-native-web/dist/vendor/react-native/FillRateHelper/index.js"],"names":["_objectSpread","Info","constructor","any_blank_count","any_blank_ms","any_blank_speed_sum","mostly_blank_count","mostly_blank_ms","pixels_blank","pixels_sampled","pixels_scrolled","total_time_spent","sample_count","DEBUG","_listeners","_minSampleCount","_sampleRate","FillRateHelper","addListener","callback","console","warn","push","remove","filter","listener","setSampleRate","sampleRate","setMinSampleCount","minSampleCount","getFrameMetrics","_anyBlankStartTime","_enabled","_info","_mostlyBlankStartTime","_samplesStartTime","_getFrameMetrics","Math","random","_resetData","activate","debug","global","performance","now","deactivateAndFlush","start","info","derived","avg_blankness","avg_speed","avg_speed_when_any_blank","any_blank_per_min","any_blank_time_frac","mostly_blank_per_min","mostly_blank_time_frac","key","round","forEach","computeBlankness","props","state","scrollMetrics","getItemCount","data","dOffset","offset","velocity","visibleLength","abs","scrollSpeed","blankTop","first","firstFrame","last","inLayout","min","max","blankBottom","lastFrame","bottomEdge","length","blankness","enabled"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAOA,aAAP,MAA0B,sCAA1B;;AAEA,MAAMC,IAAN,CAAW;AACTC,EAAAA,WAAW,GAAG;AACZ,SAAKC,eAAL,GAAuB,CAAvB;AACA,SAAKC,YAAL,GAAoB,CAApB;AACA,SAAKC,mBAAL,GAA2B,CAA3B;AACA,SAAKC,kBAAL,GAA0B,CAA1B;AACA,SAAKC,eAAL,GAAuB,CAAvB;AACA,SAAKC,YAAL,GAAoB,CAApB;AACA,SAAKC,cAAL,GAAsB,CAAtB;AACA,SAAKC,eAAL,GAAuB,CAAvB;AACA,SAAKC,gBAAL,GAAwB,CAAxB;AACA,SAAKC,YAAL,GAAoB,CAApB;AACD;;AAZQ;;AAgBX,IAAIC,KAAK,GAAG,KAAZ;AACA,IAAIC,UAAU,GAAG,EAAjB;AACA,IAAIC,eAAe,GAAG,EAAtB;;AAEA,IAAIC,WAAW,GAAGH,KAAK,GAAG,CAAH,GAAO,IAA9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,MAAMI,cAAN,CAAqB;AACD,SAAXC,WAAW,CAACC,QAAD,EAAW;AAC3B,QAAIH,WAAW,KAAK,IAApB,EAA0B;AACxBI,MAAAA,OAAO,CAACC,IAAR,CAAa,2DAAb;AACD;;AAEDP,IAAAA,UAAU,CAACQ,IAAX,CAAgBH,QAAhB;;AAEA,WAAO;AACLI,MAAAA,MAAM,EAAE,MAAM;AACZT,QAAAA,UAAU,GAAGA,UAAU,CAACU,MAAX,CAAkBC,QAAQ,IAAIN,QAAQ,KAAKM,QAA3C,CAAb;AACD;AAHI,KAAP;AAKD;;AAEmB,SAAbC,aAAa,CAACC,UAAD,EAAa;AAC/BX,IAAAA,WAAW,GAAGW,UAAd;AACD;;AAEuB,SAAjBC,iBAAiB,CAACC,cAAD,EAAiB;AACvCd,IAAAA,eAAe,GAAGc,cAAlB;AACD;;AAED3B,EAAAA,WAAW,CAAC4B,eAAD,EAAkB;AAC3B,SAAKC,kBAAL,GAA0B,IAA1B;AACA,SAAKC,QAAL,GAAgB,KAAhB;AACA,SAAKC,KAAL,GAAa,IAAIhC,IAAJ,EAAb;AACA,SAAKiC,qBAAL,GAA6B,IAA7B;AACA,SAAKC,iBAAL,GAAyB,IAAzB;AACA,SAAKC,gBAAL,GAAwBN,eAAxB;AACA,SAAKE,QAAL,GAAgB,CAAChB,WAAW,IAAI,CAAhB,IAAqBqB,IAAI,CAACC,MAAL,EAArC;;AAEA,SAAKC,UAAL;AACD;;AAEDC,EAAAA,QAAQ,GAAG;AACT,QAAI,KAAKR,QAAL,IAAiB,KAAKG,iBAAL,IAA0B,IAA/C,EAAqD;AACnDtB,MAAAA,KAAK,IAAIO,OAAO,CAACqB,KAAR,CAAc,0BAAd,CAAT;AACA,WAAKN,iBAAL,GAAyBO,MAAM,CAACC,WAAP,CAAmBC,GAAnB,EAAzB;AACD;AACF;;AAEDC,EAAAA,kBAAkB,GAAG;AACnB,QAAI,CAAC,KAAKb,QAAV,EAAoB;AAClB;AACD;;AAED,QAAIc,KAAK,GAAG,KAAKX,iBAAjB,CALmB,CAKiB;;AAEpC,QAAIW,KAAK,IAAI,IAAb,EAAmB;AACjBjC,MAAAA,KAAK,IAAIO,OAAO,CAACqB,KAAR,CAAc,uDAAd,CAAT;AACA;AACD;;AAED,QAAI,KAAKR,KAAL,CAAWrB,YAAX,GAA0BG,eAA9B,EAA+C;AAC7C;AACA,WAAKwB,UAAL;;AAEA;AACD;;AAED,QAAI5B,gBAAgB,GAAG+B,MAAM,CAACC,WAAP,CAAmBC,GAAnB,KAA2BE,KAAlD;;AAEA,QAAIC,IAAI,GAAG/C,aAAa,CAACA,aAAa,CAAC,EAAD,EAAK,KAAKiC,KAAV,CAAd,EAAgC,EAAhC,EAAoC;AAC1DtB,MAAAA;AAD0D,KAApC,CAAxB;;AAIA,QAAIE,KAAJ,EAAW;AACT,UAAImC,OAAO,GAAG;AACZC,QAAAA,aAAa,EAAE,KAAKhB,KAAL,CAAWzB,YAAX,GAA0B,KAAKyB,KAAL,CAAWxB,cADxC;AAEZyC,QAAAA,SAAS,EAAE,KAAKjB,KAAL,CAAWvB,eAAX,IAA8BC,gBAAgB,GAAG,IAAjD,CAFC;AAGZwC,QAAAA,wBAAwB,EAAE,KAAKlB,KAAL,CAAW5B,mBAAX,GAAiC,KAAK4B,KAAL,CAAW9B,eAH1D;AAIZiD,QAAAA,iBAAiB,EAAE,KAAKnB,KAAL,CAAW9B,eAAX,IAA8BQ,gBAAgB,GAAG,IAAnB,GAA0B,EAAxD,CAJP;AAKZ0C,QAAAA,mBAAmB,EAAE,KAAKpB,KAAL,CAAW7B,YAAX,GAA0BO,gBALnC;AAMZ2C,QAAAA,oBAAoB,EAAE,KAAKrB,KAAL,CAAW3B,kBAAX,IAAiCK,gBAAgB,GAAG,IAAnB,GAA0B,EAA3D,CANV;AAOZ4C,QAAAA,sBAAsB,EAAE,KAAKtB,KAAL,CAAW1B,eAAX,GAA6BI;AAPzC,OAAd;;AAUA,WAAK,IAAI6C,GAAT,IAAgBR,OAAhB,EAAyB;AACvBA,QAAAA,OAAO,CAACQ,GAAD,CAAP,GAAenB,IAAI,CAACoB,KAAL,CAAW,OAAOT,OAAO,CAACQ,GAAD,CAAzB,IAAkC,IAAjD;AACD;;AAEDpC,MAAAA,OAAO,CAACqB,KAAR,CAAc,qCAAd,EAAqD;AACnDO,QAAAA,OADmD;AAEnDD,QAAAA;AAFmD,OAArD;AAID;;AAEDjC,IAAAA,UAAU,CAAC4C,OAAX,CAAmBjC,QAAQ,IAAIA,QAAQ,CAACsB,IAAD,CAAvC;;AAEA,SAAKR,UAAL;AACD;;AAEDoB,EAAAA,gBAAgB,CAACC,KAAD,EAAQC,KAAR,EAAeC,aAAf,EAA8B;AAC5C,QAAI,CAAC,KAAK9B,QAAN,IAAkB4B,KAAK,CAACG,YAAN,CAAmBH,KAAK,CAACI,IAAzB,MAAmC,CAArD,IAA0D,KAAK7B,iBAAL,IAA0B,IAAxF,EAA8F;AAC5F,aAAO,CAAP;AACD;;AAED,QAAI8B,OAAO,GAAGH,aAAa,CAACG,OAA5B;AAAA,QACIC,MAAM,GAAGJ,aAAa,CAACI,MAD3B;AAAA,QAEIC,QAAQ,GAAGL,aAAa,CAACK,QAF7B;AAAA,QAGIC,aAAa,GAAGN,aAAa,CAACM,aAHlC,CAL4C,CAQK;AACjD;;AAEA,SAAKnC,KAAL,CAAWrB,YAAX;AACA,SAAKqB,KAAL,CAAWxB,cAAX,IAA6B4B,IAAI,CAACoB,KAAL,CAAWW,aAAX,CAA7B;AACA,SAAKnC,KAAL,CAAWvB,eAAX,IAA8B2B,IAAI,CAACoB,KAAL,CAAWpB,IAAI,CAACgC,GAAL,CAASJ,OAAT,CAAX,CAA9B;AACA,QAAIK,WAAW,GAAGjC,IAAI,CAACoB,KAAL,CAAWpB,IAAI,CAACgC,GAAL,CAASF,QAAT,IAAqB,IAAhC,CAAlB,CAd4C,CAca;AACzD;;AAEA,QAAIvB,GAAG,GAAGF,MAAM,CAACC,WAAP,CAAmBC,GAAnB,EAAV;;AAEA,QAAI,KAAKb,kBAAL,IAA2B,IAA/B,EAAqC;AACnC,WAAKE,KAAL,CAAW7B,YAAX,IAA2BwC,GAAG,GAAG,KAAKb,kBAAtC;AACD;;AAED,SAAKA,kBAAL,GAA0B,IAA1B;;AAEA,QAAI,KAAKG,qBAAL,IAA8B,IAAlC,EAAwC;AACtC,WAAKD,KAAL,CAAW1B,eAAX,IAA8BqC,GAAG,GAAG,KAAKV,qBAAzC;AACD;;AAED,SAAKA,qBAAL,GAA6B,IAA7B;AACA,QAAIqC,QAAQ,GAAG,CAAf;AACA,QAAIC,KAAK,GAAGX,KAAK,CAACW,KAAlB;;AAEA,QAAIC,UAAU,GAAG,KAAKrC,gBAAL,CAAsBoC,KAAtB,CAAjB;;AAEA,WAAOA,KAAK,IAAIX,KAAK,CAACa,IAAf,KAAwB,CAACD,UAAD,IAAe,CAACA,UAAU,CAACE,QAAnD,CAAP,EAAqE;AACnEF,MAAAA,UAAU,GAAG,KAAKrC,gBAAL,CAAsBoC,KAAtB,CAAb;AACAA,MAAAA,KAAK;AACN,KAtC2C,CAsC1C;AACF;;;AAGA,QAAIC,UAAU,IAAID,KAAK,GAAG,CAA1B,EAA6B;AAC3BD,MAAAA,QAAQ,GAAGlC,IAAI,CAACuC,GAAL,CAASR,aAAT,EAAwB/B,IAAI,CAACwC,GAAL,CAAS,CAAT,EAAYJ,UAAU,CAACP,MAAX,GAAoBA,MAAhC,CAAxB,CAAX;AACD;;AAED,QAAIY,WAAW,GAAG,CAAlB;AACA,QAAIJ,IAAI,GAAGb,KAAK,CAACa,IAAjB;;AAEA,QAAIK,SAAS,GAAG,KAAK3C,gBAAL,CAAsBsC,IAAtB,CAAhB;;AAEA,WAAOA,IAAI,IAAIb,KAAK,CAACW,KAAd,KAAwB,CAACO,SAAD,IAAc,CAACA,SAAS,CAACJ,QAAjD,CAAP,EAAmE;AACjEI,MAAAA,SAAS,GAAG,KAAK3C,gBAAL,CAAsBsC,IAAtB,CAAZ;AACAA,MAAAA,IAAI;AACL,KAtD2C,CAsD1C;AACF;;;AAGA,QAAIK,SAAS,IAAIL,IAAI,GAAGd,KAAK,CAACG,YAAN,CAAmBH,KAAK,CAACI,IAAzB,IAAiC,CAAzD,EAA4D;AAC1D,UAAIgB,UAAU,GAAGD,SAAS,CAACb,MAAV,GAAmBa,SAAS,CAACE,MAA9C;AACAH,MAAAA,WAAW,GAAGzC,IAAI,CAACuC,GAAL,CAASR,aAAT,EAAwB/B,IAAI,CAACwC,GAAL,CAAS,CAAT,EAAYX,MAAM,GAAGE,aAAT,GAAyBY,UAArC,CAAxB,CAAd;AACD;;AAED,QAAIxE,YAAY,GAAG6B,IAAI,CAACoB,KAAL,CAAWc,QAAQ,GAAGO,WAAtB,CAAnB;AACA,QAAII,SAAS,GAAG1E,YAAY,GAAG4D,aAA/B;;AAEA,QAAIc,SAAS,GAAG,CAAhB,EAAmB;AACjB,WAAKnD,kBAAL,GAA0Ba,GAA1B;AACA,WAAKX,KAAL,CAAW5B,mBAAX,IAAkCiE,WAAlC;AACA,WAAKrC,KAAL,CAAW9B,eAAX;AACA,WAAK8B,KAAL,CAAWzB,YAAX,IAA2BA,YAA3B;;AAEA,UAAI0E,SAAS,GAAG,GAAhB,EAAqB;AACnB,aAAKhD,qBAAL,GAA6BU,GAA7B;AACA,aAAKX,KAAL,CAAW3B,kBAAX;AACD;AACF,KAVD,MAUO,IAAIgE,WAAW,GAAG,IAAd,IAAsBjC,IAAI,CAACgC,GAAL,CAASJ,OAAT,IAAoB,CAA9C,EAAiD;AACtD,WAAKpB,kBAAL;AACD;;AAED,WAAOqC,SAAP;AACD;;AAEDC,EAAAA,OAAO,GAAG;AACR,WAAO,KAAKnD,QAAZ;AACD;;AAEDO,EAAAA,UAAU,GAAG;AACX,SAAKR,kBAAL,GAA0B,IAA1B;AACA,SAAKE,KAAL,GAAa,IAAIhC,IAAJ,EAAb;AACA,SAAKiC,qBAAL,GAA6B,IAA7B;AACA,SAAKC,iBAAL,GAAyB,IAAzB;AACD;;AAzLkB;;AA6LrB,eAAelB,cAAf","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\n\nclass Info {\n  constructor() {\n    this.any_blank_count = 0;\n    this.any_blank_ms = 0;\n    this.any_blank_speed_sum = 0;\n    this.mostly_blank_count = 0;\n    this.mostly_blank_ms = 0;\n    this.pixels_blank = 0;\n    this.pixels_sampled = 0;\n    this.pixels_scrolled = 0;\n    this.total_time_spent = 0;\n    this.sample_count = 0;\n  }\n\n}\n\nvar DEBUG = false;\nvar _listeners = [];\nvar _minSampleCount = 10;\n\nvar _sampleRate = DEBUG ? 1 : null;\n/**\n * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.\n * By default the sampling rate is set to zero and this will do nothing. If you want to collect\n * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.\n *\n * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with\n * `SceneTracker.getActiveScene` to determine the context of the events.\n */\n\n\nclass FillRateHelper {\n  static addListener(callback) {\n    if (_sampleRate === null) {\n      console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');\n    }\n\n    _listeners.push(callback);\n\n    return {\n      remove: () => {\n        _listeners = _listeners.filter(listener => callback !== listener);\n      }\n    };\n  }\n\n  static setSampleRate(sampleRate) {\n    _sampleRate = sampleRate;\n  }\n\n  static setMinSampleCount(minSampleCount) {\n    _minSampleCount = minSampleCount;\n  }\n\n  constructor(getFrameMetrics) {\n    this._anyBlankStartTime = null;\n    this._enabled = false;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n    this._getFrameMetrics = getFrameMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n\n    this._resetData();\n  }\n\n  activate() {\n    if (this._enabled && this._samplesStartTime == null) {\n      DEBUG && console.debug('FillRateHelper: activate');\n      this._samplesStartTime = global.performance.now();\n    }\n  }\n\n  deactivateAndFlush() {\n    if (!this._enabled) {\n      return;\n    }\n\n    var start = this._samplesStartTime; // const for flow\n\n    if (start == null) {\n      DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');\n      return;\n    }\n\n    if (this._info.sample_count < _minSampleCount) {\n      // Don't bother with under-sampled events.\n      this._resetData();\n\n      return;\n    }\n\n    var total_time_spent = global.performance.now() - start;\n\n    var info = _objectSpread(_objectSpread({}, this._info), {}, {\n      total_time_spent\n    });\n\n    if (DEBUG) {\n      var derived = {\n        avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n        avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n        avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,\n        any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),\n        any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n        mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n        mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent\n      };\n\n      for (var key in derived) {\n        derived[key] = Math.round(1000 * derived[key]) / 1000;\n      }\n\n      console.debug('FillRateHelper deactivateAndFlush: ', {\n        derived,\n        info\n      });\n    }\n\n    _listeners.forEach(listener => listener(info));\n\n    this._resetData();\n  }\n\n  computeBlankness(props, state, scrollMetrics) {\n    if (!this._enabled || props.getItemCount(props.data) === 0 || this._samplesStartTime == null) {\n      return 0;\n    }\n\n    var dOffset = scrollMetrics.dOffset,\n        offset = scrollMetrics.offset,\n        velocity = scrollMetrics.velocity,\n        visibleLength = scrollMetrics.visibleLength; // Denominator metrics that we track for all events - most of the time there is no blankness and\n    // we want to capture that.\n\n    this._info.sample_count++;\n    this._info.pixels_sampled += Math.round(visibleLength);\n    this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n    var scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec\n    // Whether blank now or not, record the elapsed time blank if we were blank last time.\n\n    var now = global.performance.now();\n\n    if (this._anyBlankStartTime != null) {\n      this._info.any_blank_ms += now - this._anyBlankStartTime;\n    }\n\n    this._anyBlankStartTime = null;\n\n    if (this._mostlyBlankStartTime != null) {\n      this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n    }\n\n    this._mostlyBlankStartTime = null;\n    var blankTop = 0;\n    var first = state.first;\n\n    var firstFrame = this._getFrameMetrics(first);\n\n    while (first <= state.last && (!firstFrame || !firstFrame.inLayout)) {\n      firstFrame = this._getFrameMetrics(first);\n      first++;\n    } // Only count blankTop if we aren't rendering the first item, otherwise we will count the header\n    // as blank.\n\n\n    if (firstFrame && first > 0) {\n      blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));\n    }\n\n    var blankBottom = 0;\n    var last = state.last;\n\n    var lastFrame = this._getFrameMetrics(last);\n\n    while (last >= state.first && (!lastFrame || !lastFrame.inLayout)) {\n      lastFrame = this._getFrameMetrics(last);\n      last--;\n    } // Only count blankBottom if we aren't rendering the last item, otherwise we will count the\n    // footer as blank.\n\n\n    if (lastFrame && last < props.getItemCount(props.data) - 1) {\n      var bottomEdge = lastFrame.offset + lastFrame.length;\n      blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));\n    }\n\n    var pixels_blank = Math.round(blankTop + blankBottom);\n    var blankness = pixels_blank / visibleLength;\n\n    if (blankness > 0) {\n      this._anyBlankStartTime = now;\n      this._info.any_blank_speed_sum += scrollSpeed;\n      this._info.any_blank_count++;\n      this._info.pixels_blank += pixels_blank;\n\n      if (blankness > 0.5) {\n        this._mostlyBlankStartTime = now;\n        this._info.mostly_blank_count++;\n      }\n    } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n      this.deactivateAndFlush();\n    }\n\n    return blankness;\n  }\n\n  enabled() {\n    return this._enabled;\n  }\n\n  _resetData() {\n    this._anyBlankStartTime = null;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n  }\n\n}\n\nexport default FillRateHelper;"]},"metadata":{},"sourceType":"module"}