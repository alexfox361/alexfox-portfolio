{"ast":null,"code":"import { sortModifiers, IMPORTANT_MODIFIER } from './modifier-utils.mjs';\nvar SPLIT_CLASSES_REGEX = /\\s+/;\n\nfunction mergeClassList(classList, configUtils) {\n  var splitModifiers = configUtils.splitModifiers,\n      getClassGroupId = configUtils.getClassGroupId,\n      getConflictingClassGroupIds = configUtils.getConflictingClassGroupIds;\n  /**\r\n   * Set of classGroupIds in following format:\r\n   * `{importantModifier}{variantModifiers}{classGroupId}`\r\n   * @example 'float'\r\n   * @example 'hover:focus:bg-color'\r\n   * @example 'md:!pr'\r\n   */\n\n  var classGroupsInConflict = new Set();\n  return classList.trim().split(SPLIT_CLASSES_REGEX).map(function (originalClassName) {\n    var _splitModifiers = splitModifiers(originalClassName),\n        modifiers = _splitModifiers.modifiers,\n        hasImportantModifier = _splitModifiers.hasImportantModifier,\n        baseClassName = _splitModifiers.baseClassName;\n\n    var classGroupId = getClassGroupId(baseClassName);\n\n    if (!classGroupId) {\n      return {\n        isTailwindClass: false,\n        originalClassName: originalClassName\n      };\n    }\n\n    var variantModifier = sortModifiers(modifiers).join(':');\n    var modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;\n    return {\n      isTailwindClass: true,\n      modifierId: modifierId,\n      classGroupId: classGroupId,\n      originalClassName: originalClassName\n    };\n  }).reverse() // Last class in conflict wins, so we need to filter conflicting classes in reverse order.\n  .filter(function (parsed) {\n    if (!parsed.isTailwindClass) {\n      return true;\n    }\n\n    var modifierId = parsed.modifierId,\n        classGroupId = parsed.classGroupId;\n    var classId = modifierId + classGroupId;\n\n    if (classGroupsInConflict.has(classId)) {\n      return false;\n    }\n\n    classGroupsInConflict.add(classId);\n    getConflictingClassGroupIds(classGroupId).forEach(function (group) {\n      return classGroupsInConflict.add(modifierId + group);\n    });\n    return true;\n  }).reverse().map(function (parsed) {\n    return parsed.originalClassName;\n  }).join(' ');\n}\n\nexport { mergeClassList };","map":{"version":3,"sources":["../../src/lib/merge-classlist.ts"],"names":["SPLIT_CLASSES_REGEX","splitModifiers","getClassGroupId","getConflictingClassGroupIds","configUtils","classGroupsInConflict","modifiers","hasImportantModifier","baseClassName","classGroupId","isTailwindClass","originalClassName","variantModifier","sortModifiers","modifierId","parsed","classId"],"mappings":";AAGA,IAAMA,mBAAmB,GAAzB,KAAA;;AAEgB,SAAA,cAAA,CAAA,SAAA,EAAA,WAAA,EAA0D;AACtE,MAAQC,cAAR,GAAyEG,WAAzE,CAAA,cAAA;AAAA,MAAwBF,eAAxB,GAAyEE,WAAzE,CAAA,eAAA;AAAA,MAAyCD,2BAAzC,GAAyEC,WAAzE,CAAA,2BAAA;AAEA;;;;;;AAMG;;AACH,MAAMC,qBAAqB,GAAG,IAA9B,GAA8B,EAA9B;AAEA,SACI,SAAS,CAAT,IAAA,GAAA,KAAA,CAAA,mBAAA,EAAA,GAAA,CAGS,UAAA,iBAAA,EAAsB;AACvB,QACIJ,eAAAA,GAAAA,cAAc,CADlB,iBACkB,CADlB;AAAA,QAAQK,SAAR,GAAA,eAAA,CAAA,SAAA;AAAA,QAAmBC,oBAAnB,GAAA,eAAA,CAAA,oBAAA;AAAA,QAAyCC,aAAzC,GAAA,eAAA,CAAA,aAAA;;AAGA,QAAMC,YAAY,GAAGP,eAAe,CAApC,aAAoC,CAApC;;AAEA,QAAI,CAAJ,YAAA,EAAmB;AACf,aAAO;AACHQ,QAAAA,eAAe,EADZ,KAAA;AAEHC,QAAAA,iBAAiB,EAAjBA;AAFG,OAAP;AAIH;;AAED,QAAMC,eAAe,GAAGC,aAAa,CAAbA,SAAa,CAAbA,CAAAA,IAAAA,CAAxB,GAAwBA,CAAxB;AAEA,QAAMC,UAAU,GAAGP,oBAAoB,GACjCK,eAAe,GADkB,kBAAA,GAAvC,eAAA;AAIA,WAAO;AACHF,MAAAA,eAAe,EADZ,IAAA;AAEHI,MAAAA,UAAU,EAFP,UAAA;AAGHL,MAAAA,YAAY,EAHT,YAAA;AAIHE,MAAAA,iBAAiB,EAAjBA;AAJG,KAAP;AAtBR,GAAA,EAAA,OAAA,GA8BI;AA9BJ,GAAA,MAAA,CA+BY,UAAA,MAAA,EAAW;AACf,QAAI,CAACI,MAAM,CAAX,eAAA,EAA6B;AACzB,aAAA,IAAA;AACH;;AAED,QAAQD,UAAR,GAAqCC,MAArC,CAAA,UAAA;AAAA,QAAoBN,YAApB,GAAqCM,MAArC,CAAA,YAAA;AAEA,QAAMC,OAAO,GAAGF,UAAU,GAA1B,YAAA;;AAEA,QAAIT,qBAAqB,CAArBA,GAAAA,CAAJ,OAAIA,CAAJ,EAAwC;AACpC,aAAA,KAAA;AACH;;AAEDA,IAAAA,qBAAqB,CAArBA,GAAAA,CAAAA,OAAAA;AAEAF,IAAAA,2BAA2B,CAA3BA,YAA2B,CAA3BA,CAAAA,OAAAA,CAAkD,UAAA,KAAA,EAAA;AAAA,aAC9CE,qBAAqB,CAArBA,GAAAA,CAA0BS,UAAU,GADU,KAC9CT,CAD8C;AAAlDF,KAAAA;AAIA,WAAA,IAAA;AAlDR,GAAA,EAAA,OAAA,GAAA,GAAA,CAqDS,UAAA,MAAA,EAAA;AAAA,WAAYY,MAAM,CAAlB,iBAAA;AArDT,GAAA,EAAA,IAAA,CADJ,GACI,CADJ;AAyDH","sourcesContent":["import { ConfigUtils } from './config-utils'\nimport { IMPORTANT_MODIFIER, sortModifiers } from './modifier-utils'\n\nconst SPLIT_CLASSES_REGEX = /\\s+/\n\nexport function mergeClassList(classList: string, configUtils: ConfigUtils) {\n    const { splitModifiers, getClassGroupId, getConflictingClassGroupIds } = configUtils\n\n    /**\n     * Set of classGroupIds in following format:\n     * `{importantModifier}{variantModifiers}{classGroupId}`\n     * @example 'float'\n     * @example 'hover:focus:bg-color'\n     * @example 'md:!pr'\n     */\n    const classGroupsInConflict = new Set<string>()\n\n    return (\n        classList\n            .trim()\n            .split(SPLIT_CLASSES_REGEX)\n            .map((originalClassName) => {\n                const { modifiers, hasImportantModifier, baseClassName } =\n                    splitModifiers(originalClassName)\n\n                const classGroupId = getClassGroupId(baseClassName)\n\n                if (!classGroupId) {\n                    return {\n                        isTailwindClass: false as const,\n                        originalClassName,\n                    }\n                }\n\n                const variantModifier = sortModifiers(modifiers).join(':')\n\n                const modifierId = hasImportantModifier\n                    ? variantModifier + IMPORTANT_MODIFIER\n                    : variantModifier\n\n                return {\n                    isTailwindClass: true as const,\n                    modifierId,\n                    classGroupId,\n                    originalClassName,\n                }\n            })\n            .reverse()\n            // Last class in conflict wins, so we need to filter conflicting classes in reverse order.\n            .filter((parsed) => {\n                if (!parsed.isTailwindClass) {\n                    return true\n                }\n\n                const { modifierId, classGroupId } = parsed\n\n                const classId = modifierId + classGroupId\n\n                if (classGroupsInConflict.has(classId)) {\n                    return false\n                }\n\n                classGroupsInConflict.add(classId)\n\n                getConflictingClassGroupIds(classGroupId).forEach((group) =>\n                    classGroupsInConflict.add(modifierId + group),\n                )\n\n                return true\n            })\n            .reverse()\n            .map((parsed) => parsed.originalClassName)\n            .join(' ')\n    )\n}\n"]},"metadata":{},"sourceType":"module"}