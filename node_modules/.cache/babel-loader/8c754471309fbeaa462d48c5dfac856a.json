{"ast":null,"code":"var CLASS_PART_SEPARATOR = '-';\n\nfunction createClassUtils(config) {\n  var classMap = createClassMap(config);\n\n  function getClassGroupId(className) {\n    var classParts = className.split(CLASS_PART_SEPARATOR); // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.\n\n    if (classParts[0] === '' && classParts.length !== 1) {\n      classParts.shift();\n    }\n\n    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);\n  }\n\n  function getConflictingClassGroupIds(classGroupId) {\n    return config.conflictingClassGroups[classGroupId] || [];\n  }\n\n  return {\n    getClassGroupId: getClassGroupId,\n    getConflictingClassGroupIds: getConflictingClassGroupIds\n  };\n}\n\nfunction getGroupRecursive(classParts, classPartObject) {\n  var _classPartObject$vali;\n\n  if (classParts.length === 0) {\n    return classPartObject.classGroupId;\n  }\n\n  var currentClassPart = classParts[0];\n  var nextClassPartObject = classPartObject.nextPart.get(currentClassPart);\n  var classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : undefined;\n\n  if (classGroupFromNextClassPart) {\n    return classGroupFromNextClassPart;\n  }\n\n  if (classPartObject.validators.length === 0) {\n    return undefined;\n  }\n\n  var classRest = classParts.join(CLASS_PART_SEPARATOR);\n  return (_classPartObject$vali = classPartObject.validators.find(function (_ref) {\n    var validator = _ref.validator;\n    return validator(classRest);\n  })) == null ? void 0 : _classPartObject$vali.classGroupId;\n}\n\nvar arbitraryPropertyRegex = /^\\[(.+)\\]$/;\n\nfunction getGroupIdForArbitraryProperty(className) {\n  if (arbitraryPropertyRegex.test(className)) {\n    var arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];\n    var property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(':'));\n\n    if (property) {\n      // I use two dots here because one dot is used as prefix for class groups in plugins\n      return 'arbitrary..' + property;\n    }\n  }\n}\n/**\r\n * Exported for testing only\r\n */\n\n\nfunction createClassMap(config) {\n  var theme = config.theme,\n      prefix = config.prefix;\n  var classMap = {\n    nextPart: new Map(),\n    validators: []\n  };\n  var prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);\n  prefixedClassGroupEntries.forEach(function (_ref2) {\n    var classGroupId = _ref2[0],\n        classGroup = _ref2[1];\n    processClassesRecursively(classGroup, classMap, classGroupId, theme);\n  });\n  return classMap;\n}\n\nfunction processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {\n  classGroup.forEach(function (classDefinition) {\n    if (typeof classDefinition === 'string') {\n      var classPartObjectToEdit = classDefinition === '' ? classPartObject : getPart(classPartObject, classDefinition);\n      classPartObjectToEdit.classGroupId = classGroupId;\n      return;\n    }\n\n    if (typeof classDefinition === 'function') {\n      if (isThemeGetter(classDefinition)) {\n        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);\n        return;\n      }\n\n      classPartObject.validators.push({\n        validator: classDefinition,\n        classGroupId: classGroupId\n      });\n      return;\n    }\n\n    Object.entries(classDefinition).forEach(function (_ref3) {\n      var key = _ref3[0],\n          classGroup = _ref3[1];\n      processClassesRecursively(classGroup, getPart(classPartObject, key), classGroupId, theme);\n    });\n  });\n}\n\nfunction getPart(classPartObject, path) {\n  var currentClassPartObject = classPartObject;\n  path.split(CLASS_PART_SEPARATOR).forEach(function (pathPart) {\n    if (!currentClassPartObject.nextPart.has(pathPart)) {\n      currentClassPartObject.nextPart.set(pathPart, {\n        nextPart: new Map(),\n        validators: []\n      });\n    }\n\n    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);\n  });\n  return currentClassPartObject;\n}\n\nfunction isThemeGetter(func) {\n  return func.isThemeGetter;\n}\n\nfunction getPrefixedClassGroupEntries(classGroupEntries, prefix) {\n  if (!prefix) {\n    return classGroupEntries;\n  }\n\n  return classGroupEntries.map(function (_ref4) {\n    var classGroupId = _ref4[0],\n        classGroup = _ref4[1];\n    var prefixedClassGroup = classGroup.map(function (classDefinition) {\n      if (typeof classDefinition === 'string') {\n        return prefix + classDefinition;\n      }\n\n      if (typeof classDefinition === 'object') {\n        return Object.fromEntries(Object.entries(classDefinition).map(function (_ref5) {\n          var key = _ref5[0],\n              value = _ref5[1];\n          return [prefix + key, value];\n        }));\n      }\n\n      return classDefinition;\n    });\n    return [classGroupId, prefixedClassGroup];\n  });\n}\n\nexport { createClassMap, createClassUtils };","map":{"version":3,"sources":["../../src/lib/class-utils.ts"],"names":["CLASS_PART_SEPARATOR","classMap","createClassMap","classParts","className","getGroupRecursive","getGroupIdForArbitraryProperty","config","getClassGroupId","getConflictingClassGroupIds","classPartObject","currentClassPart","nextClassPartObject","classGroupFromNextClassPart","classRest","validator","arbitraryPropertyRegex","arbitraryPropertyClassName","property","theme","prefix","nextPart","validators","prefixedClassGroupEntries","getPrefixedClassGroupEntries","Object","classGroupId","classGroup","processClassesRecursively","classPartObjectToEdit","classDefinition","getPart","isThemeGetter","key","currentClassPartObject","path","func","prefixedClassGroup","value"],"mappings":"AAaA,IAAMA,oBAAoB,GAA1B,GAAA;;AAEM,SAAA,gBAAA,CAAA,MAAA,EAAyC;AAC3C,MAAMC,QAAQ,GAAGC,cAAc,CAA/B,MAA+B,CAA/B;;AAEA,WAAA,eAAA,CAAA,SAAA,EAA0C;AACtC,QAAMC,UAAU,GAAGC,SAAS,CAATA,KAAAA,CADmB,oBACnBA,CAAnB,CADsC,CAAA;;AAItC,QAAID,UAAU,CAAVA,CAAU,CAAVA,KAAAA,EAAAA,IAAwBA,UAAU,CAAVA,MAAAA,KAA5B,CAAA,EAAqD;AACjDA,MAAAA,UAAU,CAAVA,KAAAA;AACH;;AAED,WAAOE,iBAAiB,CAAA,UAAA,EAAjBA,QAAiB,CAAjBA,IAA2CC,8BAA8B,CAAhF,SAAgF,CAAhF;AACH;;AAED,WAAA,2BAAA,CAAA,YAAA,EAA+D;AAC3D,WAAOC,MAAM,CAANA,sBAAAA,CAAAA,YAAAA,KAAP,EAAA;AACH;;AAED,SAAO;AACHC,IAAAA,eAAe,EADZ,eAAA;AAEHC,IAAAA,2BAA2B,EAA3BA;AAFG,GAAP;AAIH;;AAED,SAAA,iBAAA,CAAA,UAAA,EAAA,eAAA,EAEoC;AAAA,MAAA,qBAAA;;AAEhC,MAAIN,UAAU,CAAVA,MAAAA,KAAJ,CAAA,EAA6B;AACzB,WAAOO,eAAe,CAAtB,YAAA;AACH;;AAED,MAAMC,gBAAgB,GAAGR,UAAU,CAAnC,CAAmC,CAAnC;AACA,MAAMS,mBAAmB,GAAGF,eAAe,CAAfA,QAAAA,CAAAA,GAAAA,CAA5B,gBAA4BA,CAA5B;AACA,MAAMG,2BAA2B,GAAGD,mBAAmB,GACjDP,iBAAiB,CAACF,UAAU,CAAVA,KAAAA,CAAD,CAACA,CAAD,EADgC,mBAChC,CADgC,GAAvD,SAAA;;AAIA,MAAA,2BAAA,EAAiC;AAC7B,WAAA,2BAAA;AACH;;AAED,MAAIO,eAAe,CAAfA,UAAAA,CAAAA,MAAAA,KAAJ,CAAA,EAA6C;AACzC,WAAA,SAAA;AACH;;AAED,MAAMI,SAAS,GAAGX,UAAU,CAAVA,IAAAA,CAAlB,oBAAkBA,CAAlB;AAEA,SAAA,CAAA,qBAAA,GAAO,eAAe,CAAf,UAAA,CAAA,IAAA,CAAgC,UAAA,IAAA,EAAA;AAAA,QAAGY,SAAH,GAAA,IAAA,CAAA,SAAA;AAAA,WAAmBA,SAAS,CAA5B,SAA4B,CAA5B;AAAvC,GAAO,CAAP,KAAO,IAAP,GAAO,KAAA,CAAP,GAAO,qBAAA,CAAP,YAAA;AACH;;AAED,IAAMC,sBAAsB,GAA5B,YAAA;;AAEA,SAAA,8BAAA,CAAA,SAAA,EAAyD;AACrD,MAAIA,sBAAsB,CAAtBA,IAAAA,CAAJ,SAAIA,CAAJ,EAA4C;AACxC,QAAMC,0BAA0B,GAAGD,sBAAsB,CAAtBA,IAAAA,CAAAA,SAAAA,EAAnC,CAAmCA,CAAnC;AACA,QAAME,QAAQ,GAAGD,0BAAH,IAAGA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,0BAA0B,CAA1BA,SAAAA,CAAAA,CAAAA,EAEbA,0BAA0B,CAA1BA,OAAAA,CAFJ,GAEIA,CAFaA,CAAjB;;AAKA,QAAA,QAAA,EAAc;AACV;AACA,aAAO,gBAAP,QAAA;AACH;AACJ;AACJ;AAED;;AAEG;;;AACG,SAAA,cAAA,CAAA,MAAA,EAAuC;AACzC,MAAQE,KAAR,GAA0BZ,MAA1B,CAAA,KAAA;AAAA,MAAea,MAAf,GAA0Bb,MAA1B,CAAA,MAAA;AACA,MAAMN,QAAQ,GAAoB;AAC9BoB,IAAAA,QAAQ,EAAE,IADoB,GACpB,EADoB;AAE9BC,IAAAA,UAAU,EAAE;AAFkB,GAAlC;AAKA,MAAMC,yBAAyB,GAAGC,4BAA4B,CAC1DC,MAAM,CAANA,OAAAA,CAAelB,MAAM,CADqC,WAC1DkB,CAD0D,EAA9D,MAA8D,CAA9D;AAKAF,EAAAA,yBAAyB,CAAzBA,OAAAA,CAAkC,UAA+B,KAA/B,EAA+B;AAAA,QAA7BG,YAA6B,GAAA,KAAA,CAAA,CAAA,CAAA;AAAA,QAAfC,UAAe,GAAA,KAAA,CAAA,CAAA,CAAA;AAC7DC,IAAAA,yBAAyB,CAAA,UAAA,EAAA,QAAA,EAAA,YAAA,EAAzBA,KAAyB,CAAzBA;AADJL,GAAAA;AAIA,SAAA,QAAA;AACH;;AAED,SAAA,yBAAA,CAAA,UAAA,EAAA,eAAA,EAAA,YAAA,EAAA,KAAA,EAIsB;AAElBI,EAAAA,UAAU,CAAVA,OAAAA,CAAmB,UAAA,eAAA,EAAoB;AACnC,QAAI,OAAA,eAAA,KAAJ,QAAA,EAAyC;AACrC,UAAME,qBAAqB,GACvBC,eAAe,KAAfA,EAAAA,GAAAA,eAAAA,GAA2CC,OAAO,CAAA,eAAA,EADtD,eACsD,CADtD;AAEAF,MAAAA,qBAAqB,CAArBA,YAAAA,GAAAA,YAAAA;AACA;AACH;;AAED,QAAI,OAAA,eAAA,KAAJ,UAAA,EAA2C;AACvC,UAAIG,aAAa,CAAjB,eAAiB,CAAjB,EAAoC;AAChCJ,QAAAA,yBAAyB,CACrBE,eAAe,CADM,KACN,CADM,EAAA,eAAA,EAAA,YAAA,EAAzBF,KAAyB,CAAzBA;AAMA;AACH;;AAEDlB,MAAAA,eAAe,CAAfA,UAAAA,CAAAA,IAAAA,CAAgC;AAC5BK,QAAAA,SAAS,EADmB,eAAA;AAE5BW,QAAAA,YAAY,EAAZA;AAF4B,OAAhChB;AAKA;AACH;;AAEDe,IAAAA,MAAM,CAANA,OAAAA,CAAAA,eAAAA,EAAAA,OAAAA,CAAwC,UAAsB,KAAtB,EAAsB;AAAA,UAApBQ,GAAoB,GAAA,KAAA,CAAA,CAAA,CAAA;AAAA,UAAfN,UAAe,GAAA,KAAA,CAAA,CAAA,CAAA;AAC1DC,MAAAA,yBAAyB,CAAA,UAAA,EAErBG,OAAO,CAAA,eAAA,EAFc,GAEd,CAFc,EAAA,YAAA,EAAzBH,KAAyB,CAAzBA;AADJH,KAAAA;AA3BJE,GAAAA;AAoCH;;AAED,SAAA,OAAA,CAAA,eAAA,EAAA,IAAA,EAA+D;AAC3D,MAAIO,sBAAsB,GAA1B,eAAA;AAEAC,EAAAA,IAAI,CAAJA,KAAAA,CAAAA,oBAAAA,EAAAA,OAAAA,CAAyC,UAAA,QAAA,EAAa;AAClD,QAAI,CAACD,sBAAsB,CAAtBA,QAAAA,CAAAA,GAAAA,CAAL,QAAKA,CAAL,EAAoD;AAChDA,MAAAA,sBAAsB,CAAtBA,QAAAA,CAAAA,GAAAA,CAAAA,QAAAA,EAA8C;AAC1Cb,QAAAA,QAAQ,EAAE,IADgC,GAChC,EADgC;AAE1CC,QAAAA,UAAU,EAAE;AAF8B,OAA9CY;AAIH;;AAEDA,IAAAA,sBAAsB,GAAGA,sBAAsB,CAAtBA,QAAAA,CAAAA,GAAAA,CAAzBA,QAAyBA,CAAzBA;AARJC,GAAAA;AAWA,SAAA,sBAAA;AACH;;AAED,SAAA,aAAA,CAAA,IAAA,EAAyD;AACrD,SAAQC,IAAoB,CAA5B,aAAA;AACH;;AAED,SAAA,4BAAA,CAAA,iBAAA,EAAA,MAAA,EAE8B;AAE1B,MAAI,CAAJ,MAAA,EAAa;AACT,WAAA,iBAAA;AACH;;AAED,SAAO,iBAAiB,CAAjB,GAAA,CAAsB,UAA+B,KAA/B,EAA+B;AAAA,QAA7BV,YAA6B,GAAA,KAAA,CAAA,CAAA,CAAA;AAAA,QAAfC,UAAe,GAAA,KAAA,CAAA,CAAA,CAAA;AACxD,QAAMU,kBAAkB,GAAG,UAAU,CAAV,GAAA,CAAe,UAAA,eAAA,EAAoB;AAC1D,UAAI,OAAA,eAAA,KAAJ,QAAA,EAAyC;AACrC,eAAOjB,MAAM,GAAb,eAAA;AACH;;AAED,UAAI,OAAA,eAAA,KAAJ,QAAA,EAAyC;AACrC,eAAO,MAAM,CAAN,WAAA,CACH,MAAM,CAAN,OAAA,CAAA,eAAA,EAAA,GAAA,CAAoC,UAAA,KAAA,EAAA;AAAA,cAAEa,GAAF,GAAA,KAAA,CAAA,CAAA,CAAA;AAAA,cAAOK,KAAP,GAAA,KAAA,CAAA,CAAA,CAAA;AAAA,iBAAkB,CAAClB,MAAM,GAAP,GAAA,EAAlB,KAAkB,CAAlB;AADxC,SACI,CADG,CAAP;AAGH;;AAED,aAAA,eAAA;AAXJ,KAA2B,CAA3B;AAcA,WAAO,CAAA,YAAA,EAAP,kBAAO,CAAP;AAfJ,GAAO,CAAP;AAiBH","sourcesContent":["import { ClassGroupId, Config, ClassGroup, ClassValidator, ThemeObject, ThemeGetter } from './types'\n\nexport interface ClassPartObject {\n    nextPart: Map<string, ClassPartObject>\n    validators: ClassValidatorObject[]\n    classGroupId?: ClassGroupId\n}\n\ninterface ClassValidatorObject {\n    classGroupId: ClassGroupId\n    validator: ClassValidator\n}\n\nconst CLASS_PART_SEPARATOR = '-'\n\nexport function createClassUtils(config: Config) {\n    const classMap = createClassMap(config)\n\n    function getClassGroupId(className: string) {\n        const classParts = className.split(CLASS_PART_SEPARATOR)\n\n        // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.\n        if (classParts[0] === '' && classParts.length !== 1) {\n            classParts.shift()\n        }\n\n        return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className)\n    }\n\n    function getConflictingClassGroupIds(classGroupId: ClassGroupId) {\n        return config.conflictingClassGroups[classGroupId] || []\n    }\n\n    return {\n        getClassGroupId,\n        getConflictingClassGroupIds,\n    }\n}\n\nfunction getGroupRecursive(\n    classParts: string[],\n    classPartObject: ClassPartObject,\n): ClassGroupId | undefined {\n    if (classParts.length === 0) {\n        return classPartObject.classGroupId\n    }\n\n    const currentClassPart = classParts[0]!\n    const nextClassPartObject = classPartObject.nextPart.get(currentClassPart)\n    const classGroupFromNextClassPart = nextClassPartObject\n        ? getGroupRecursive(classParts.slice(1), nextClassPartObject)\n        : undefined\n\n    if (classGroupFromNextClassPart) {\n        return classGroupFromNextClassPart\n    }\n\n    if (classPartObject.validators.length === 0) {\n        return undefined\n    }\n\n    const classRest = classParts.join(CLASS_PART_SEPARATOR)\n\n    return classPartObject.validators.find(({ validator }) => validator(classRest))?.classGroupId\n}\n\nconst arbitraryPropertyRegex = /^\\[(.+)\\]$/\n\nfunction getGroupIdForArbitraryProperty(className: string) {\n    if (arbitraryPropertyRegex.test(className)) {\n        const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)![1]\n        const property = arbitraryPropertyClassName?.substring(\n            0,\n            arbitraryPropertyClassName.indexOf(':'),\n        )\n\n        if (property) {\n            // I use two dots here because one dot is used as prefix for class groups in plugins\n            return 'arbitrary..' + property\n        }\n    }\n}\n\n/**\n * Exported for testing only\n */\nexport function createClassMap(config: Config) {\n    const { theme, prefix } = config\n    const classMap: ClassPartObject = {\n        nextPart: new Map<string, ClassPartObject>(),\n        validators: [],\n    }\n\n    const prefixedClassGroupEntries = getPrefixedClassGroupEntries(\n        Object.entries(config.classGroups),\n        prefix,\n    )\n\n    prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {\n        processClassesRecursively(classGroup, classMap, classGroupId, theme)\n    })\n\n    return classMap\n}\n\nfunction processClassesRecursively(\n    classGroup: ClassGroup,\n    classPartObject: ClassPartObject,\n    classGroupId: ClassGroupId,\n    theme: ThemeObject,\n) {\n    classGroup.forEach((classDefinition) => {\n        if (typeof classDefinition === 'string') {\n            const classPartObjectToEdit =\n                classDefinition === '' ? classPartObject : getPart(classPartObject, classDefinition)\n            classPartObjectToEdit.classGroupId = classGroupId\n            return\n        }\n\n        if (typeof classDefinition === 'function') {\n            if (isThemeGetter(classDefinition)) {\n                processClassesRecursively(\n                    classDefinition(theme),\n                    classPartObject,\n                    classGroupId,\n                    theme,\n                )\n                return\n            }\n\n            classPartObject.validators.push({\n                validator: classDefinition,\n                classGroupId,\n            })\n\n            return\n        }\n\n        Object.entries(classDefinition).forEach(([key, classGroup]) => {\n            processClassesRecursively(\n                classGroup,\n                getPart(classPartObject, key),\n                classGroupId,\n                theme,\n            )\n        })\n    })\n}\n\nfunction getPart(classPartObject: ClassPartObject, path: string) {\n    let currentClassPartObject = classPartObject\n\n    path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {\n        if (!currentClassPartObject.nextPart.has(pathPart)) {\n            currentClassPartObject.nextPart.set(pathPart, {\n                nextPart: new Map(),\n                validators: [],\n            })\n        }\n\n        currentClassPartObject = currentClassPartObject.nextPart.get(pathPart)!\n    })\n\n    return currentClassPartObject\n}\n\nfunction isThemeGetter(func: ClassValidator | ThemeGetter): func is ThemeGetter {\n    return (func as ThemeGetter).isThemeGetter\n}\n\nfunction getPrefixedClassGroupEntries(\n    classGroupEntries: Array<[classGroupId: string, classGroup: ClassGroup]>,\n    prefix: string | undefined,\n): Array<[classGroupId: string, classGroup: ClassGroup]> {\n    if (!prefix) {\n        return classGroupEntries\n    }\n\n    return classGroupEntries.map(([classGroupId, classGroup]) => {\n        const prefixedClassGroup = classGroup.map((classDefinition) => {\n            if (typeof classDefinition === 'string') {\n                return prefix + classDefinition\n            }\n\n            if (typeof classDefinition === 'object') {\n                return Object.fromEntries(\n                    Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]),\n                )\n            }\n\n            return classDefinition\n        })\n\n        return [classGroupId, prefixedClassGroup]\n    })\n}\n"]},"metadata":{},"sourceType":"module"}