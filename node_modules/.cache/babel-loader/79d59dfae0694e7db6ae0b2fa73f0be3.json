{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { isStartish, isMoveish, isEndish } from './ResponderEventTypes';\n/**\n * Tracks the position and time of each active touch by `touch.identifier`. We\n * should typically only see IDs in the range of 1-20 because IDs get recycled\n * when touches end and start again.\n */\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar MAX_TOUCH_BANK = 20;\n\nfunction timestampForTouch(touch) {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\".\n  return touch.timeStamp || touch.timestamp;\n}\n/**\n * TODO: Instead of making gestures recompute filtered velocity, we could\n * include a built in velocity computation that can be reused globally.\n */\n\n\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n\n  if (identifier == null) {\n    console.error('Touch object is missing identifier.');\n  }\n\n  if (__DEV__) {\n    if (identifier > MAX_TOUCH_BANK) {\n      console.error('Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);\n    }\n  }\n\n  return identifier;\n}\n\nfunction recordTouchStart(touch, touchHistory) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchHistory.touchBank[identifier];\n\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchHistory.touchBank[identifier] = createTouchRecord(touch);\n  }\n\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch, touchHistory) {\n  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch move without a touch start.\\n', \"Touch Move: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank(touchHistory));\n  }\n}\n\nfunction recordTouchEnd(touch, touchHistory) {\n  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch end without a touch start.\\n', \"Touch End: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank(touchHistory));\n  }\n}\n\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank(touchHistory) {\n  var touchBank = touchHistory.touchBank;\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += ' (original size: ' + touchBank.length + ')';\n  }\n\n  return printed;\n}\n\nexport class ResponderTouchHistoryStore {\n  constructor() {\n    this._touchHistory = {\n      touchBank: [],\n      //Array<TouchRecord>\n      numberActiveTouches: 0,\n      // If there is only one active touch, we remember its location. This prevents\n      // us having to loop through all of the touches all the time in the most\n      // common case.\n      indexOfSingleActiveTouch: -1,\n      mostRecentTimeStamp: 0\n    };\n  }\n\n  recordTouchTrack(topLevelType, nativeEvent) {\n    var touchHistory = this._touchHistory;\n\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(touch => recordTouchMove(touch, touchHistory));\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(touch => recordTouchStart(touch, touchHistory));\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(touch => recordTouchEnd(touch, touchHistory));\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        var touchBank = touchHistory.touchBank;\n\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n\n        if (__DEV__) {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n\n          if (!(activeRecord != null && activeRecord.touchActive)) {\n            console.error('Cannot find single active touch.');\n          }\n        }\n      }\n    }\n  }\n\n  get touchHistory() {\n    return this._touchHistory;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/alex/Documents/GitHub/alexfox-portfolio/node_modules/react-native-web/dist/modules/useResponderEvents/ResponderTouchHistoryStore.js"],"names":["isStartish","isMoveish","isEndish","__DEV__","process","env","NODE_ENV","MAX_TOUCH_BANK","timestampForTouch","touch","timeStamp","timestamp","createTouchRecord","touchActive","startPageX","pageX","startPageY","pageY","startTimeStamp","currentPageX","currentPageY","currentTimeStamp","previousPageX","previousPageY","previousTimeStamp","resetTouchRecord","touchRecord","getTouchIdentifier","_ref","identifier","console","error","recordTouchStart","touchHistory","touchBank","mostRecentTimeStamp","recordTouchMove","warn","printTouch","printTouchBank","recordTouchEnd","JSON","stringify","printed","slice","length","ResponderTouchHistoryStore","constructor","_touchHistory","numberActiveTouches","indexOfSingleActiveTouch","recordTouchTrack","topLevelType","nativeEvent","changedTouches","forEach","touches","i","touchTrackToCheck","activeRecord"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nimport { isStartish, isMoveish, isEndish } from './ResponderEventTypes';\n\n/**\n * Tracks the position and time of each active touch by `touch.identifier`. We\n * should typically only see IDs in the range of 1-20 because IDs get recycled\n * when touches end and start again.\n */\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar MAX_TOUCH_BANK = 20;\n\nfunction timestampForTouch(touch) {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\".\n  return touch.timeStamp || touch.timestamp;\n}\n/**\n * TODO: Instead of making gestures recompute filtered velocity, we could\n * include a built in velocity computation that can be reused globally.\n */\n\n\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n\n  if (identifier == null) {\n    console.error('Touch object is missing identifier.');\n  }\n\n  if (__DEV__) {\n    if (identifier > MAX_TOUCH_BANK) {\n      console.error('Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);\n    }\n  }\n\n  return identifier;\n}\n\nfunction recordTouchStart(touch, touchHistory) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchHistory.touchBank[identifier];\n\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchHistory.touchBank[identifier] = createTouchRecord(touch);\n  }\n\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch, touchHistory) {\n  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch move without a touch start.\\n', \"Touch Move: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank(touchHistory));\n  }\n}\n\nfunction recordTouchEnd(touch, touchHistory) {\n  var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch end without a touch start.\\n', \"Touch End: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank(touchHistory));\n  }\n}\n\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank(touchHistory) {\n  var touchBank = touchHistory.touchBank;\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += ' (original size: ' + touchBank.length + ')';\n  }\n\n  return printed;\n}\n\nexport class ResponderTouchHistoryStore {\n  constructor() {\n    this._touchHistory = {\n      touchBank: [],\n      //Array<TouchRecord>\n      numberActiveTouches: 0,\n      // If there is only one active touch, we remember its location. This prevents\n      // us having to loop through all of the touches all the time in the most\n      // common case.\n      indexOfSingleActiveTouch: -1,\n      mostRecentTimeStamp: 0\n    };\n  }\n\n  recordTouchTrack(topLevelType, nativeEvent) {\n    var touchHistory = this._touchHistory;\n\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(touch => recordTouchMove(touch, touchHistory));\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(touch => recordTouchStart(touch, touchHistory));\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(touch => recordTouchEnd(touch, touchHistory));\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        var touchBank = touchHistory.touchBank;\n\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n\n        if (__DEV__) {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n\n          if (!(activeRecord != null && activeRecord.touchActive)) {\n            console.error('Cannot find single active touch.');\n          }\n        }\n      }\n    }\n  }\n\n  get touchHistory() {\n    return this._touchHistory;\n  }\n\n}"]},"metadata":{},"sourceType":"module"}