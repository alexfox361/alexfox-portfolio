{"ast":null,"code":"var IMPORTANT_MODIFIER = '!';\n\nfunction createSplitModifiers(config) {\n  var separator = config.separator || ':'; // splitModifiers inspired by https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js\n\n  return function splitModifiers(className) {\n    var bracketDepth = 0;\n    var modifiers = [];\n    var modifierStart = 0;\n\n    for (var index = 0; index < className.length; index++) {\n      var _char = className[index];\n\n      if (bracketDepth === 0 && _char === separator[0]) {\n        if (separator.length === 1 || className.slice(index, index + separator.length) === separator) {\n          modifiers.push(className.slice(modifierStart, index));\n          modifierStart = index + separator.length;\n        }\n      }\n\n      if (_char === '[') {\n        bracketDepth++;\n      } else if (_char === ']') {\n        bracketDepth--;\n      }\n    }\n\n    var baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);\n    var hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);\n    var baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;\n    return {\n      modifiers: modifiers,\n      hasImportantModifier: hasImportantModifier,\n      baseClassName: baseClassName\n    };\n  };\n}\n/**\r\n * Sorts modifiers according to following schema:\r\n * - Predefined modifiers are sorted alphabetically\r\n * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it\r\n */\n\n\nfunction sortModifiers(modifiers) {\n  if (modifiers.length <= 1) {\n    return modifiers;\n  }\n\n  var sortedModifiers = [];\n  var unsortedModifiers = [];\n  modifiers.forEach(function (modifier) {\n    var isArbitraryVariant = modifier[0] === '[';\n\n    if (isArbitraryVariant) {\n      sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort().concat([modifier]));\n      unsortedModifiers = [];\n    } else {\n      unsortedModifiers.push(modifier);\n    }\n  });\n  sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort());\n  return sortedModifiers;\n}\n\nexport { IMPORTANT_MODIFIER, createSplitModifiers, sortModifiers };","map":{"version":3,"sources":["../../src/lib/modifier-utils.ts"],"names":["IMPORTANT_MODIFIER","separator","config","bracketDepth","modifiers","modifierStart","index","className","char","baseClassNameWithImportantModifier","hasImportantModifier","baseClassName","sortedModifiers","unsortedModifiers","isArbitraryVariant","modifier"],"mappings":"AAEO,IAAMA,kBAAkB,GAAxB,GAAA;;AAED,SAAA,oBAAA,CAAA,MAAA,EAA6C;AAC/C,MAAMC,SAAS,GAAGC,MAAM,CAANA,SAAAA,IAD6B,GAC/C,CAD+C,CAAA;;AAI/C,SAAO,SAAA,cAAA,CAAA,SAAA,EAAyC;AAC5C,QAAIC,YAAY,GAAhB,CAAA;AACA,QAAIC,SAAS,GAAb,EAAA;AACA,QAAIC,aAAa,GAAjB,CAAA;;AAEA,SAAK,IAAIC,KAAK,GAAd,CAAA,EAAoBA,KAAK,GAAGC,SAAS,CAArC,MAAA,EAA8CD,KAA9C,EAAA,EAAuD;AACnD,UAAIE,KAAI,GAAGD,SAAS,CAApB,KAAoB,CAApB;;AAEA,UAAIJ,YAAY,KAAZA,CAAAA,IAAsBK,KAAI,KAAKP,SAAS,CAA5C,CAA4C,CAA5C,EAAiD;AAC7C,YACIA,SAAS,CAATA,MAAAA,KAAAA,CAAAA,IACAM,SAAS,CAATA,KAAAA,CAAAA,KAAAA,EAAuBD,KAAK,GAAGL,SAAS,CAAxCM,MAAAA,MAFJ,SAAA,EAGE;AACEH,UAAAA,SAAS,CAATA,IAAAA,CAAeG,SAAS,CAATA,KAAAA,CAAAA,aAAAA,EAAfH,KAAeG,CAAfH;AACAC,UAAAA,aAAa,GAAGC,KAAK,GAAGL,SAAS,CAAjCI,MAAAA;AACH;AACJ;;AAED,UAAIG,KAAI,KAAR,GAAA,EAAkB;AACdL,QAAAA,YAAY;AADhB,OAAA,MAEO,IAAIK,KAAI,KAAR,GAAA,EAAkB;AACrBL,QAAAA,YAAY;AACf;AACJ;;AAED,QAAMM,kCAAkC,GACpCL,SAAS,CAATA,MAAAA,KAAAA,CAAAA,GAAAA,SAAAA,GAAqCG,SAAS,CAATA,SAAAA,CADzC,aACyCA,CADzC;AAEA,QAAMG,oBAAoB,GACtBD,kCAAkC,CAAlCA,UAAAA,CADJ,kBACIA,CADJ;AAEA,QAAME,aAAa,GAAGD,oBAAoB,GACpCD,kCAAkC,CAAlCA,SAAAA,CADoC,CACpCA,CADoC,GAA1C,kCAAA;AAIA,WAAO;AACHL,MAAAA,SAAS,EADN,SAAA;AAEHM,MAAAA,oBAAoB,EAFjB,oBAAA;AAGHC,MAAAA,aAAa,EAAbA;AAHG,KAAP;AAjCJ,GAAA;AAuCH;AAED;;;;AAIG;;;AACG,SAAA,aAAA,CAAA,SAAA,EAA2C;AAC7C,MAAIP,SAAS,CAATA,MAAAA,IAAJ,CAAA,EAA2B;AACvB,WAAA,SAAA;AACH;;AAED,MAAMQ,eAAe,GAArB,EAAA;AACA,MAAIC,iBAAiB,GAArB,EAAA;AAEAT,EAAAA,SAAS,CAATA,OAAAA,CAAkB,UAAA,QAAA,EAAa;AAC3B,QAAMU,kBAAkB,GAAGC,QAAQ,CAARA,CAAQ,CAARA,KAA3B,GAAA;;AAEA,QAAA,kBAAA,EAAwB;AACpBH,MAAAA,eAAe,CAAfA,IAAAA,CAAAA,KAAAA,CAAAA,eAAAA,EAAwBC,iBAAiB,CAA1B,IAASA,GAA0BE,MAA1BF,CAA0BE,CAAlDH,QAAkDG,CAA1BF,CAAxBD;AACAC,MAAAA,iBAAiB,GAAjBA,EAAAA;AAFJ,KAAA,MAGO;AACHA,MAAAA,iBAAiB,CAAjBA,IAAAA,CAAAA,QAAAA;AACH;AARLT,GAAAA;AAWAQ,EAAAA,eAAe,CAAfA,IAAAA,CAAAA,KAAAA,CAAAA,eAAAA,EAAwBC,iBAAiB,CAAzCD,IAAwBC,EAAxBD;AAEA,SAAA,eAAA;AACH","sourcesContent":["import { Config } from './types'\n\nexport const IMPORTANT_MODIFIER = '!'\n\nexport function createSplitModifiers(config: Config) {\n    const separator = config.separator || ':'\n\n    // splitModifiers inspired by https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js\n    return function splitModifiers(className: string) {\n        let bracketDepth = 0\n        let modifiers = []\n        let modifierStart = 0\n\n        for (let index = 0; index < className.length; index++) {\n            let char = className[index]\n\n            if (bracketDepth === 0 && char === separator[0]) {\n                if (\n                    separator.length === 1 ||\n                    className.slice(index, index + separator.length) === separator\n                ) {\n                    modifiers.push(className.slice(modifierStart, index))\n                    modifierStart = index + separator.length\n                }\n            }\n\n            if (char === '[') {\n                bracketDepth++\n            } else if (char === ']') {\n                bracketDepth--\n            }\n        }\n\n        const baseClassNameWithImportantModifier =\n            modifiers.length === 0 ? className : className.substring(modifierStart)\n        const hasImportantModifier =\n            baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER)\n        const baseClassName = hasImportantModifier\n            ? baseClassNameWithImportantModifier.substring(1)\n            : baseClassNameWithImportantModifier\n\n        return {\n            modifiers,\n            hasImportantModifier,\n            baseClassName,\n        }\n    }\n}\n\n/**\n * Sorts modifiers according to following schema:\n * - Predefined modifiers are sorted alphabetically\n * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it\n */\nexport function sortModifiers(modifiers: string[]) {\n    if (modifiers.length <= 1) {\n        return modifiers\n    }\n\n    const sortedModifiers: string[] = []\n    let unsortedModifiers: string[] = []\n\n    modifiers.forEach((modifier) => {\n        const isArbitraryVariant = modifier[0] === '['\n\n        if (isArbitraryVariant) {\n            sortedModifiers.push(...unsortedModifiers.sort(), modifier)\n            unsortedModifiers = []\n        } else {\n            unsortedModifiers.push(modifier)\n        }\n    })\n\n    sortedModifiers.push(...unsortedModifiers.sort())\n\n    return sortedModifiers\n}\n"]},"metadata":{},"sourceType":"module"}