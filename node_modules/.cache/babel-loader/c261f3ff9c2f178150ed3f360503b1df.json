{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nvar DELAY = 'DELAY';\nvar ERROR = 'ERROR';\nvar LONG_PRESS_DETECTED = 'LONG_PRESS_DETECTED';\nvar NOT_RESPONDER = 'NOT_RESPONDER';\nvar RESPONDER_ACTIVE_LONG_PRESS_START = 'RESPONDER_ACTIVE_LONG_PRESS_START';\nvar RESPONDER_ACTIVE_PRESS_START = 'RESPONDER_ACTIVE_PRESS_START';\nvar RESPONDER_INACTIVE_PRESS_START = 'RESPONDER_INACTIVE_PRESS_START';\nvar RESPONDER_GRANT = 'RESPONDER_GRANT';\nvar RESPONDER_RELEASE = 'RESPONDER_RELEASE';\nvar RESPONDER_TERMINATED = 'RESPONDER_TERMINATED';\nvar Transitions = Object.freeze({\n  NOT_RESPONDER: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: ERROR,\n    RESPONDER_TERMINATED: ERROR,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_START: {\n    DELAY: RESPONDER_ACTIVE_PRESS_START,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  ERROR: {\n    DELAY: NOT_RESPONDER,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: NOT_RESPONDER\n  }\n});\n\nvar isActiveSignal = signal => signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\n\nvar isButtonRole = element => element.getAttribute('role') === 'button';\n\nvar isPressStartSignal = signal => signal === RESPONDER_INACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\n\nvar isTerminalSignal = signal => signal === RESPONDER_TERMINATED || signal === RESPONDER_RELEASE;\n\nvar isValidKeyPress = event => {\n  var key = event.key,\n      target = event.target;\n  var role = target.getAttribute('role');\n  var isSpacebar = key === ' ' || key === 'Spacebar';\n  return key === 'Enter' || isSpacebar && role === 'button';\n};\n\nvar DEFAULT_LONG_PRESS_DELAY_MS = 450; // 500 - 50\n\nvar DEFAULT_PRESS_DELAY_MS = 50;\n/**\n * =========================== PressResponder Tutorial ===========================\n *\n * The `PressResponder` class helps you create press interactions by analyzing the\n * geometry of elements and observing when another responder (e.g. ScrollView)\n * has stolen the touch lock. It offers hooks for your component to provide\n * interaction feedback to the user:\n *\n * - When a press has activated (e.g. highlight an element)\n * - When a press has deactivated (e.g. un-highlight an element)\n * - When a press sould trigger an action, meaning it activated and deactivated\n *   while within the geometry of the element without the lock being stolen.\n *\n * A high quality interaction isn't as simple as you might think. There should\n * be a slight delay before activation. Moving your finger beyond an element's\n * bounds should trigger deactivation, but moving the same finger back within an\n * element's bounds should trigger reactivation.\n *\n * In order to use `PressResponder`, do the following:\n *\n *     const pressResponder = new PressResponder(config);\n *\n * 2. Choose the rendered component who should collect the press events. On that\n *    element, spread `pressability.getEventHandlers()` into its props.\n *\n *    return (\n *      <View {...this.state.pressResponder.getEventHandlers()} />\n *    );\n *\n * 3. Reset `PressResponder` when your component unmounts.\n *\n *    componentWillUnmount() {\n *      this.state.pressResponder.reset();\n *    }\n *\n * ==================== Implementation Details ====================\n *\n * `PressResponder` only assumes that there exists a `HitRect` node. The `PressRect`\n * is an abstract box that is extended beyond the `HitRect`.\n *\n * # Geometry\n *\n *  ┌────────────────────────┐\n *  │  ┌──────────────────┐  │ - Presses start anywhere within `HitRect`.\n *  │  │  ┌────────────┐  │  │\n *  │  │  │ VisualRect │  │  │\n *  │  │  └────────────┘  │  │ - When pressed down for sufficient amount of time\n *  │  │    HitRect       │  │   before letting up, `VisualRect` activates.\n *  │  └──────────────────┘  │\n *  │       Out Region   o   │\n *  └────────────────────│───┘\n *                       └────── When the press is released outside the `HitRect`,\n *                               the responder is NOT eligible for a \"press\".\n *\n * # State Machine\n *\n * ┌───────────────┐ ◀──── RESPONDER_RELEASE\n * │ NOT_RESPONDER │\n * └───┬───────────┘ ◀──── RESPONDER_TERMINATED\n *     │\n *     │ RESPONDER_GRANT (HitRect)\n *     │\n *     ▼\n * ┌─────────────────────┐          ┌───────────────────┐              ┌───────────────────┐\n * │ RESPONDER_INACTIVE_ │  DELAY   │ RESPONDER_ACTIVE_ │  T + DELAY   │ RESPONDER_ACTIVE_ │\n * │ PRESS_START         ├────────▶ │ PRESS_START       ├────────────▶ │ LONG_PRESS_START  │\n * └─────────────────────┘          └───────────────────┘              └───────────────────┘\n *\n * T + DELAY => LONG_PRESS_DELAY + DELAY\n *\n * Not drawn are the side effects of each transition. The most important side\n * effect is the invocation of `onLongPress`. Only when the browser produces a\n * `click` event is `onPress` invoked.\n */\n\nexport default class PressResponder {\n  constructor(config) {\n    this._eventHandlers = null;\n    this._isPointerTouch = false;\n    this._longPressDelayTimeout = null;\n    this._longPressDispatched = false;\n    this._pressDelayTimeout = null;\n    this._pressOutDelayTimeout = null;\n    this._touchState = NOT_RESPONDER;\n    this.configure(config);\n  }\n\n  configure(config) {\n    this._config = config;\n  }\n  /**\n   * Resets any pending timers. This should be called on unmount.\n   */\n\n\n  reset() {\n    this._cancelLongPressDelayTimeout();\n\n    this._cancelPressDelayTimeout();\n\n    this._cancelPressOutDelayTimeout();\n  }\n  /**\n   * Returns a set of props to spread into the interactive element.\n   */\n\n\n  getEventHandlers() {\n    if (this._eventHandlers == null) {\n      this._eventHandlers = this._createEventHandlers();\n    }\n\n    return this._eventHandlers;\n  }\n\n  _createEventHandlers() {\n    var start = (event, shouldDelay) => {\n      event.persist();\n\n      this._cancelPressOutDelayTimeout();\n\n      this._longPressDispatched = false;\n      this._selectionTerminated = false;\n      this._touchState = NOT_RESPONDER;\n      this._isPointerTouch = event.nativeEvent.type === 'touchstart';\n\n      this._receiveSignal(RESPONDER_GRANT, event);\n\n      var delayPressStart = normalizeDelay(this._config.delayPressStart, 0, DEFAULT_PRESS_DELAY_MS);\n\n      if (shouldDelay !== false && delayPressStart > 0) {\n        this._pressDelayTimeout = setTimeout(() => {\n          this._receiveSignal(DELAY, event);\n        }, delayPressStart);\n      } else {\n        this._receiveSignal(DELAY, event);\n      }\n\n      var delayLongPress = normalizeDelay(this._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS);\n      this._longPressDelayTimeout = setTimeout(() => {\n        this._handleLongPress(event);\n      }, delayLongPress + delayPressStart);\n    };\n\n    var end = event => {\n      this._receiveSignal(RESPONDER_RELEASE, event);\n    };\n\n    var keyupHandler = event => {\n      var onPress = this._config.onPress;\n      var target = event.target;\n\n      if (this._touchState !== NOT_RESPONDER && isValidKeyPress(event)) {\n        end(event);\n        document.removeEventListener('keyup', keyupHandler);\n        var role = target.getAttribute('role');\n        var elementType = target.tagName.toLowerCase();\n        var isNativeInteractiveElement = role === 'link' || elementType === 'a' || elementType === 'button' || elementType === 'input' || elementType === 'select' || elementType === 'textarea';\n\n        if (onPress != null && !isNativeInteractiveElement) {\n          onPress(event);\n        }\n      }\n    };\n\n    return {\n      onStartShouldSetResponder: event => {\n        var disabled = this._config.disabled;\n\n        if (disabled && isButtonRole(event.currentTarget)) {\n          event.stopPropagation();\n        }\n\n        if (disabled == null) {\n          return true;\n        }\n\n        return !disabled;\n      },\n      onKeyDown: event => {\n        var disabled = this._config.disabled;\n        var key = event.key,\n            target = event.target;\n\n        if (!disabled && isValidKeyPress(event)) {\n          if (this._touchState === NOT_RESPONDER) {\n            start(event, false); // Listen to 'keyup' on document to account for situations where\n            // focus is moved to another element during 'keydown'.\n\n            document.addEventListener('keyup', keyupHandler);\n          }\n\n          var role = target.getAttribute('role');\n          var isSpacebarKey = key === ' ' || key === 'Spacebar';\n\n          var _isButtonRole = role === 'button' || role === 'menuitem';\n\n          if (isSpacebarKey && _isButtonRole) {\n            // Prevent spacebar scrolling the window\n            event.preventDefault();\n          }\n\n          event.stopPropagation();\n        }\n      },\n      onResponderGrant: event => start(event),\n      onResponderMove: event => {\n        if (this._config.onPressMove != null) {\n          this._config.onPressMove(event);\n        }\n\n        var touch = getTouchFromResponderEvent(event);\n\n        if (this._touchActivatePosition != null) {\n          var deltaX = this._touchActivatePosition.pageX - touch.pageX;\n          var deltaY = this._touchActivatePosition.pageY - touch.pageY;\n\n          if (Math.hypot(deltaX, deltaY) > 10) {\n            this._cancelLongPressDelayTimeout();\n          }\n        }\n      },\n      onResponderRelease: event => end(event),\n      onResponderTerminate: event => {\n        if (event.nativeEvent.type === 'selectionchange') {\n          this._selectionTerminated = true;\n        }\n\n        this._receiveSignal(RESPONDER_TERMINATED, event);\n      },\n      onResponderTerminationRequest: event => {\n        var _this$_config = this._config,\n            cancelable = _this$_config.cancelable,\n            disabled = _this$_config.disabled,\n            onLongPress = _this$_config.onLongPress; // If `onLongPress` is provided, don't terminate on `contextmenu` as default\n        // behavior will be prevented for non-mouse pointers.\n\n        if (!disabled && onLongPress != null && this._isPointerTouch && event.nativeEvent.type === 'contextmenu') {\n          return false;\n        }\n\n        if (cancelable == null) {\n          return true;\n        }\n\n        return cancelable;\n      },\n      // NOTE: this diverges from react-native in 3 significant ways:\n      // * The `onPress` callback is not connected to the responder system (the native\n      //  `click` event must be used but is dispatched in many scenarios where no pointers\n      //   are on the screen.) Therefore, it's possible for `onPress` to be called without\n      //   `onPress{Start,End}` being called first.\n      // * The `onPress` callback is only be called on the first ancestor of the native\n      //   `click` target that is using the PressResponder.\n      // * The event's `nativeEvent` is a `MouseEvent` not a `TouchEvent`.\n      onClick: event => {\n        var _this$_config2 = this._config,\n            disabled = _this$_config2.disabled,\n            onPress = _this$_config2.onPress;\n\n        if (!disabled) {\n          // If long press dispatched, cancel default click behavior.\n          // If the responder terminated because text was selected during the gesture,\n          // cancel the default click behavior.\n          event.stopPropagation();\n\n          if (this._longPressDispatched || this._selectionTerminated) {\n            event.preventDefault();\n          } else if (onPress != null && event.altKey === false) {\n            onPress(event);\n          }\n        } else {\n          if (isButtonRole(event.currentTarget)) {\n            event.stopPropagation();\n          }\n        }\n      },\n      // If `onLongPress` is provided and a touch pointer is being used, prevent the\n      // default context menu from opening.\n      onContextMenu: event => {\n        var _this$_config3 = this._config,\n            disabled = _this$_config3.disabled,\n            onLongPress = _this$_config3.onLongPress;\n\n        if (!disabled) {\n          if (onLongPress != null && this._isPointerTouch && !event.defaultPrevented) {\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        } else {\n          if (isButtonRole(event.currentTarget)) {\n            event.stopPropagation();\n          }\n        }\n      }\n    };\n  }\n  /**\n   * Receives a state machine signal, performs side effects of the transition\n   * and stores the new state. Validates the transition as well.\n   */\n\n\n  _receiveSignal(signal, event) {\n    var prevState = this._touchState;\n    var nextState = null;\n\n    if (Transitions[prevState] != null) {\n      nextState = Transitions[prevState][signal];\n    }\n\n    if (this._touchState === NOT_RESPONDER && signal === RESPONDER_RELEASE) {\n      return;\n    }\n\n    if (nextState == null || nextState === ERROR) {\n      console.error(\"PressResponder: Invalid signal \" + signal + \" for state \" + prevState + \" on responder\");\n    } else if (prevState !== nextState) {\n      this._performTransitionSideEffects(prevState, nextState, signal, event);\n\n      this._touchState = nextState;\n    }\n  }\n  /**\n   * Performs a transition between touchable states and identify any activations\n   * or deactivations (and callback invocations).\n   */\n\n\n  _performTransitionSideEffects(prevState, nextState, signal, event) {\n    if (isTerminalSignal(signal)) {\n      // Pressable suppression of contextmenu on windows.\n      // On Windows, the contextmenu is displayed after pointerup.\n      // https://github.com/necolas/react-native-web/issues/2296\n      setTimeout(() => {\n        this._isPointerTouch = false;\n      }, 0);\n      this._touchActivatePosition = null;\n\n      this._cancelLongPressDelayTimeout();\n    }\n\n    if (isPressStartSignal(prevState) && signal === LONG_PRESS_DETECTED) {\n      var onLongPress = this._config.onLongPress; // Long press is not supported for keyboards because 'click' can be dispatched\n      // immediately (and multiple times) after 'keydown'.\n\n      if (onLongPress != null && event.nativeEvent.key == null) {\n        onLongPress(event);\n        this._longPressDispatched = true;\n      }\n    }\n\n    var isPrevActive = isActiveSignal(prevState);\n    var isNextActive = isActiveSignal(nextState);\n\n    if (!isPrevActive && isNextActive) {\n      this._activate(event);\n    } else if (isPrevActive && !isNextActive) {\n      this._deactivate(event);\n    }\n\n    if (isPressStartSignal(prevState) && signal === RESPONDER_RELEASE) {\n      var _this$_config4 = this._config,\n          _onLongPress = _this$_config4.onLongPress,\n          onPress = _this$_config4.onPress;\n\n      if (onPress != null) {\n        var isPressCanceledByLongPress = _onLongPress != null && prevState === RESPONDER_ACTIVE_LONG_PRESS_START;\n\n        if (!isPressCanceledByLongPress) {\n          // If we never activated (due to delays), activate and deactivate now.\n          if (!isNextActive && !isPrevActive) {\n            this._activate(event);\n\n            this._deactivate(event);\n          }\n        }\n      }\n    }\n\n    this._cancelPressDelayTimeout();\n  }\n\n  _activate(event) {\n    var _this$_config5 = this._config,\n        onPressChange = _this$_config5.onPressChange,\n        onPressStart = _this$_config5.onPressStart;\n    var touch = getTouchFromResponderEvent(event);\n    this._touchActivatePosition = {\n      pageX: touch.pageX,\n      pageY: touch.pageY\n    };\n\n    if (onPressStart != null) {\n      onPressStart(event);\n    }\n\n    if (onPressChange != null) {\n      onPressChange(true);\n    }\n  }\n\n  _deactivate(event) {\n    var _this$_config6 = this._config,\n        onPressChange = _this$_config6.onPressChange,\n        onPressEnd = _this$_config6.onPressEnd;\n\n    function end() {\n      if (onPressEnd != null) {\n        onPressEnd(event);\n      }\n\n      if (onPressChange != null) {\n        onPressChange(false);\n      }\n    }\n\n    var delayPressEnd = normalizeDelay(this._config.delayPressEnd);\n\n    if (delayPressEnd > 0) {\n      this._pressOutDelayTimeout = setTimeout(() => {\n        end();\n      }, delayPressEnd);\n    } else {\n      end();\n    }\n  }\n\n  _handleLongPress(event) {\n    if (this._touchState === RESPONDER_ACTIVE_PRESS_START || this._touchState === RESPONDER_ACTIVE_LONG_PRESS_START) {\n      this._receiveSignal(LONG_PRESS_DETECTED, event);\n    }\n  }\n\n  _cancelLongPressDelayTimeout() {\n    if (this._longPressDelayTimeout != null) {\n      clearTimeout(this._longPressDelayTimeout);\n      this._longPressDelayTimeout = null;\n    }\n  }\n\n  _cancelPressDelayTimeout() {\n    if (this._pressDelayTimeout != null) {\n      clearTimeout(this._pressDelayTimeout);\n      this._pressDelayTimeout = null;\n    }\n  }\n\n  _cancelPressOutDelayTimeout() {\n    if (this._pressOutDelayTimeout != null) {\n      clearTimeout(this._pressOutDelayTimeout);\n      this._pressOutDelayTimeout = null;\n    }\n  }\n\n}\n\nfunction normalizeDelay(delay, min, fallback) {\n  if (min === void 0) {\n    min = 0;\n  }\n\n  if (fallback === void 0) {\n    fallback = 0;\n  }\n\n  return Math.max(min, delay !== null && delay !== void 0 ? delay : fallback);\n}\n\nfunction getTouchFromResponderEvent(event) {\n  var _event$nativeEvent = event.nativeEvent,\n      changedTouches = _event$nativeEvent.changedTouches,\n      touches = _event$nativeEvent.touches;\n\n  if (touches != null && touches.length > 0) {\n    return touches[0];\n  }\n\n  if (changedTouches != null && changedTouches.length > 0) {\n    return changedTouches[0];\n  }\n\n  return event.nativeEvent;\n}","map":{"version":3,"sources":["C:/Users/alex/Documents/GitHub/alexfox-portfolio/node_modules/react-native-web/dist/modules/usePressEvents/PressResponder.js"],"names":["DELAY","ERROR","LONG_PRESS_DETECTED","NOT_RESPONDER","RESPONDER_ACTIVE_LONG_PRESS_START","RESPONDER_ACTIVE_PRESS_START","RESPONDER_INACTIVE_PRESS_START","RESPONDER_GRANT","RESPONDER_RELEASE","RESPONDER_TERMINATED","Transitions","Object","freeze","isActiveSignal","signal","isButtonRole","element","getAttribute","isPressStartSignal","isTerminalSignal","isValidKeyPress","event","key","target","role","isSpacebar","DEFAULT_LONG_PRESS_DELAY_MS","DEFAULT_PRESS_DELAY_MS","PressResponder","constructor","config","_eventHandlers","_isPointerTouch","_longPressDelayTimeout","_longPressDispatched","_pressDelayTimeout","_pressOutDelayTimeout","_touchState","configure","_config","reset","_cancelLongPressDelayTimeout","_cancelPressDelayTimeout","_cancelPressOutDelayTimeout","getEventHandlers","_createEventHandlers","start","shouldDelay","persist","_selectionTerminated","nativeEvent","type","_receiveSignal","delayPressStart","normalizeDelay","setTimeout","delayLongPress","_handleLongPress","end","keyupHandler","onPress","document","removeEventListener","elementType","tagName","toLowerCase","isNativeInteractiveElement","onStartShouldSetResponder","disabled","currentTarget","stopPropagation","onKeyDown","addEventListener","isSpacebarKey","_isButtonRole","preventDefault","onResponderGrant","onResponderMove","onPressMove","touch","getTouchFromResponderEvent","_touchActivatePosition","deltaX","pageX","deltaY","pageY","Math","hypot","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","_this$_config","cancelable","onLongPress","onClick","_this$_config2","altKey","onContextMenu","_this$_config3","defaultPrevented","prevState","nextState","console","error","_performTransitionSideEffects","isPrevActive","isNextActive","_activate","_deactivate","_this$_config4","_onLongPress","isPressCanceledByLongPress","_this$_config5","onPressChange","onPressStart","_this$_config6","onPressEnd","delayPressEnd","clearTimeout","delay","min","fallback","max","_event$nativeEvent","changedTouches","touches","length"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nvar DELAY = 'DELAY';\nvar ERROR = 'ERROR';\nvar LONG_PRESS_DETECTED = 'LONG_PRESS_DETECTED';\nvar NOT_RESPONDER = 'NOT_RESPONDER';\nvar RESPONDER_ACTIVE_LONG_PRESS_START = 'RESPONDER_ACTIVE_LONG_PRESS_START';\nvar RESPONDER_ACTIVE_PRESS_START = 'RESPONDER_ACTIVE_PRESS_START';\nvar RESPONDER_INACTIVE_PRESS_START = 'RESPONDER_INACTIVE_PRESS_START';\nvar RESPONDER_GRANT = 'RESPONDER_GRANT';\nvar RESPONDER_RELEASE = 'RESPONDER_RELEASE';\nvar RESPONDER_TERMINATED = 'RESPONDER_TERMINATED';\nvar Transitions = Object.freeze({\n  NOT_RESPONDER: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: ERROR,\n    RESPONDER_TERMINATED: ERROR,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_START: {\n    DELAY: RESPONDER_ACTIVE_PRESS_START,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  ERROR: {\n    DELAY: NOT_RESPONDER,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: NOT_RESPONDER\n  }\n});\n\nvar isActiveSignal = signal => signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\n\nvar isButtonRole = element => element.getAttribute('role') === 'button';\n\nvar isPressStartSignal = signal => signal === RESPONDER_INACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\n\nvar isTerminalSignal = signal => signal === RESPONDER_TERMINATED || signal === RESPONDER_RELEASE;\n\nvar isValidKeyPress = event => {\n  var key = event.key,\n      target = event.target;\n  var role = target.getAttribute('role');\n  var isSpacebar = key === ' ' || key === 'Spacebar';\n  return key === 'Enter' || isSpacebar && role === 'button';\n};\n\nvar DEFAULT_LONG_PRESS_DELAY_MS = 450; // 500 - 50\n\nvar DEFAULT_PRESS_DELAY_MS = 50;\n/**\n * =========================== PressResponder Tutorial ===========================\n *\n * The `PressResponder` class helps you create press interactions by analyzing the\n * geometry of elements and observing when another responder (e.g. ScrollView)\n * has stolen the touch lock. It offers hooks for your component to provide\n * interaction feedback to the user:\n *\n * - When a press has activated (e.g. highlight an element)\n * - When a press has deactivated (e.g. un-highlight an element)\n * - When a press sould trigger an action, meaning it activated and deactivated\n *   while within the geometry of the element without the lock being stolen.\n *\n * A high quality interaction isn't as simple as you might think. There should\n * be a slight delay before activation. Moving your finger beyond an element's\n * bounds should trigger deactivation, but moving the same finger back within an\n * element's bounds should trigger reactivation.\n *\n * In order to use `PressResponder`, do the following:\n *\n *     const pressResponder = new PressResponder(config);\n *\n * 2. Choose the rendered component who should collect the press events. On that\n *    element, spread `pressability.getEventHandlers()` into its props.\n *\n *    return (\n *      <View {...this.state.pressResponder.getEventHandlers()} />\n *    );\n *\n * 3. Reset `PressResponder` when your component unmounts.\n *\n *    componentWillUnmount() {\n *      this.state.pressResponder.reset();\n *    }\n *\n * ==================== Implementation Details ====================\n *\n * `PressResponder` only assumes that there exists a `HitRect` node. The `PressRect`\n * is an abstract box that is extended beyond the `HitRect`.\n *\n * # Geometry\n *\n *  ┌────────────────────────┐\n *  │  ┌──────────────────┐  │ - Presses start anywhere within `HitRect`.\n *  │  │  ┌────────────┐  │  │\n *  │  │  │ VisualRect │  │  │\n *  │  │  └────────────┘  │  │ - When pressed down for sufficient amount of time\n *  │  │    HitRect       │  │   before letting up, `VisualRect` activates.\n *  │  └──────────────────┘  │\n *  │       Out Region   o   │\n *  └────────────────────│───┘\n *                       └────── When the press is released outside the `HitRect`,\n *                               the responder is NOT eligible for a \"press\".\n *\n * # State Machine\n *\n * ┌───────────────┐ ◀──── RESPONDER_RELEASE\n * │ NOT_RESPONDER │\n * └───┬───────────┘ ◀──── RESPONDER_TERMINATED\n *     │\n *     │ RESPONDER_GRANT (HitRect)\n *     │\n *     ▼\n * ┌─────────────────────┐          ┌───────────────────┐              ┌───────────────────┐\n * │ RESPONDER_INACTIVE_ │  DELAY   │ RESPONDER_ACTIVE_ │  T + DELAY   │ RESPONDER_ACTIVE_ │\n * │ PRESS_START         ├────────▶ │ PRESS_START       ├────────────▶ │ LONG_PRESS_START  │\n * └─────────────────────┘          └───────────────────┘              └───────────────────┘\n *\n * T + DELAY => LONG_PRESS_DELAY + DELAY\n *\n * Not drawn are the side effects of each transition. The most important side\n * effect is the invocation of `onLongPress`. Only when the browser produces a\n * `click` event is `onPress` invoked.\n */\n\nexport default class PressResponder {\n  constructor(config) {\n    this._eventHandlers = null;\n    this._isPointerTouch = false;\n    this._longPressDelayTimeout = null;\n    this._longPressDispatched = false;\n    this._pressDelayTimeout = null;\n    this._pressOutDelayTimeout = null;\n    this._touchState = NOT_RESPONDER;\n    this.configure(config);\n  }\n\n  configure(config) {\n    this._config = config;\n  }\n  /**\n   * Resets any pending timers. This should be called on unmount.\n   */\n\n\n  reset() {\n    this._cancelLongPressDelayTimeout();\n\n    this._cancelPressDelayTimeout();\n\n    this._cancelPressOutDelayTimeout();\n  }\n  /**\n   * Returns a set of props to spread into the interactive element.\n   */\n\n\n  getEventHandlers() {\n    if (this._eventHandlers == null) {\n      this._eventHandlers = this._createEventHandlers();\n    }\n\n    return this._eventHandlers;\n  }\n\n  _createEventHandlers() {\n    var start = (event, shouldDelay) => {\n      event.persist();\n\n      this._cancelPressOutDelayTimeout();\n\n      this._longPressDispatched = false;\n      this._selectionTerminated = false;\n      this._touchState = NOT_RESPONDER;\n      this._isPointerTouch = event.nativeEvent.type === 'touchstart';\n\n      this._receiveSignal(RESPONDER_GRANT, event);\n\n      var delayPressStart = normalizeDelay(this._config.delayPressStart, 0, DEFAULT_PRESS_DELAY_MS);\n\n      if (shouldDelay !== false && delayPressStart > 0) {\n        this._pressDelayTimeout = setTimeout(() => {\n          this._receiveSignal(DELAY, event);\n        }, delayPressStart);\n      } else {\n        this._receiveSignal(DELAY, event);\n      }\n\n      var delayLongPress = normalizeDelay(this._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS);\n      this._longPressDelayTimeout = setTimeout(() => {\n        this._handleLongPress(event);\n      }, delayLongPress + delayPressStart);\n    };\n\n    var end = event => {\n      this._receiveSignal(RESPONDER_RELEASE, event);\n    };\n\n    var keyupHandler = event => {\n      var onPress = this._config.onPress;\n      var target = event.target;\n\n      if (this._touchState !== NOT_RESPONDER && isValidKeyPress(event)) {\n        end(event);\n        document.removeEventListener('keyup', keyupHandler);\n        var role = target.getAttribute('role');\n        var elementType = target.tagName.toLowerCase();\n        var isNativeInteractiveElement = role === 'link' || elementType === 'a' || elementType === 'button' || elementType === 'input' || elementType === 'select' || elementType === 'textarea';\n\n        if (onPress != null && !isNativeInteractiveElement) {\n          onPress(event);\n        }\n      }\n    };\n\n    return {\n      onStartShouldSetResponder: event => {\n        var disabled = this._config.disabled;\n\n        if (disabled && isButtonRole(event.currentTarget)) {\n          event.stopPropagation();\n        }\n\n        if (disabled == null) {\n          return true;\n        }\n\n        return !disabled;\n      },\n      onKeyDown: event => {\n        var disabled = this._config.disabled;\n        var key = event.key,\n            target = event.target;\n\n        if (!disabled && isValidKeyPress(event)) {\n          if (this._touchState === NOT_RESPONDER) {\n            start(event, false); // Listen to 'keyup' on document to account for situations where\n            // focus is moved to another element during 'keydown'.\n\n            document.addEventListener('keyup', keyupHandler);\n          }\n\n          var role = target.getAttribute('role');\n          var isSpacebarKey = key === ' ' || key === 'Spacebar';\n\n          var _isButtonRole = role === 'button' || role === 'menuitem';\n\n          if (isSpacebarKey && _isButtonRole) {\n            // Prevent spacebar scrolling the window\n            event.preventDefault();\n          }\n\n          event.stopPropagation();\n        }\n      },\n      onResponderGrant: event => start(event),\n      onResponderMove: event => {\n        if (this._config.onPressMove != null) {\n          this._config.onPressMove(event);\n        }\n\n        var touch = getTouchFromResponderEvent(event);\n\n        if (this._touchActivatePosition != null) {\n          var deltaX = this._touchActivatePosition.pageX - touch.pageX;\n          var deltaY = this._touchActivatePosition.pageY - touch.pageY;\n\n          if (Math.hypot(deltaX, deltaY) > 10) {\n            this._cancelLongPressDelayTimeout();\n          }\n        }\n      },\n      onResponderRelease: event => end(event),\n      onResponderTerminate: event => {\n        if (event.nativeEvent.type === 'selectionchange') {\n          this._selectionTerminated = true;\n        }\n\n        this._receiveSignal(RESPONDER_TERMINATED, event);\n      },\n      onResponderTerminationRequest: event => {\n        var _this$_config = this._config,\n            cancelable = _this$_config.cancelable,\n            disabled = _this$_config.disabled,\n            onLongPress = _this$_config.onLongPress; // If `onLongPress` is provided, don't terminate on `contextmenu` as default\n        // behavior will be prevented for non-mouse pointers.\n\n        if (!disabled && onLongPress != null && this._isPointerTouch && event.nativeEvent.type === 'contextmenu') {\n          return false;\n        }\n\n        if (cancelable == null) {\n          return true;\n        }\n\n        return cancelable;\n      },\n      // NOTE: this diverges from react-native in 3 significant ways:\n      // * The `onPress` callback is not connected to the responder system (the native\n      //  `click` event must be used but is dispatched in many scenarios where no pointers\n      //   are on the screen.) Therefore, it's possible for `onPress` to be called without\n      //   `onPress{Start,End}` being called first.\n      // * The `onPress` callback is only be called on the first ancestor of the native\n      //   `click` target that is using the PressResponder.\n      // * The event's `nativeEvent` is a `MouseEvent` not a `TouchEvent`.\n      onClick: event => {\n        var _this$_config2 = this._config,\n            disabled = _this$_config2.disabled,\n            onPress = _this$_config2.onPress;\n\n        if (!disabled) {\n          // If long press dispatched, cancel default click behavior.\n          // If the responder terminated because text was selected during the gesture,\n          // cancel the default click behavior.\n          event.stopPropagation();\n\n          if (this._longPressDispatched || this._selectionTerminated) {\n            event.preventDefault();\n          } else if (onPress != null && event.altKey === false) {\n            onPress(event);\n          }\n        } else {\n          if (isButtonRole(event.currentTarget)) {\n            event.stopPropagation();\n          }\n        }\n      },\n      // If `onLongPress` is provided and a touch pointer is being used, prevent the\n      // default context menu from opening.\n      onContextMenu: event => {\n        var _this$_config3 = this._config,\n            disabled = _this$_config3.disabled,\n            onLongPress = _this$_config3.onLongPress;\n\n        if (!disabled) {\n          if (onLongPress != null && this._isPointerTouch && !event.defaultPrevented) {\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        } else {\n          if (isButtonRole(event.currentTarget)) {\n            event.stopPropagation();\n          }\n        }\n      }\n    };\n  }\n  /**\n   * Receives a state machine signal, performs side effects of the transition\n   * and stores the new state. Validates the transition as well.\n   */\n\n\n  _receiveSignal(signal, event) {\n    var prevState = this._touchState;\n    var nextState = null;\n\n    if (Transitions[prevState] != null) {\n      nextState = Transitions[prevState][signal];\n    }\n\n    if (this._touchState === NOT_RESPONDER && signal === RESPONDER_RELEASE) {\n      return;\n    }\n\n    if (nextState == null || nextState === ERROR) {\n      console.error(\"PressResponder: Invalid signal \" + signal + \" for state \" + prevState + \" on responder\");\n    } else if (prevState !== nextState) {\n      this._performTransitionSideEffects(prevState, nextState, signal, event);\n\n      this._touchState = nextState;\n    }\n  }\n  /**\n   * Performs a transition between touchable states and identify any activations\n   * or deactivations (and callback invocations).\n   */\n\n\n  _performTransitionSideEffects(prevState, nextState, signal, event) {\n    if (isTerminalSignal(signal)) {\n      // Pressable suppression of contextmenu on windows.\n      // On Windows, the contextmenu is displayed after pointerup.\n      // https://github.com/necolas/react-native-web/issues/2296\n      setTimeout(() => {\n        this._isPointerTouch = false;\n      }, 0);\n      this._touchActivatePosition = null;\n\n      this._cancelLongPressDelayTimeout();\n    }\n\n    if (isPressStartSignal(prevState) && signal === LONG_PRESS_DETECTED) {\n      var onLongPress = this._config.onLongPress; // Long press is not supported for keyboards because 'click' can be dispatched\n      // immediately (and multiple times) after 'keydown'.\n\n      if (onLongPress != null && event.nativeEvent.key == null) {\n        onLongPress(event);\n        this._longPressDispatched = true;\n      }\n    }\n\n    var isPrevActive = isActiveSignal(prevState);\n    var isNextActive = isActiveSignal(nextState);\n\n    if (!isPrevActive && isNextActive) {\n      this._activate(event);\n    } else if (isPrevActive && !isNextActive) {\n      this._deactivate(event);\n    }\n\n    if (isPressStartSignal(prevState) && signal === RESPONDER_RELEASE) {\n      var _this$_config4 = this._config,\n          _onLongPress = _this$_config4.onLongPress,\n          onPress = _this$_config4.onPress;\n\n      if (onPress != null) {\n        var isPressCanceledByLongPress = _onLongPress != null && prevState === RESPONDER_ACTIVE_LONG_PRESS_START;\n\n        if (!isPressCanceledByLongPress) {\n          // If we never activated (due to delays), activate and deactivate now.\n          if (!isNextActive && !isPrevActive) {\n            this._activate(event);\n\n            this._deactivate(event);\n          }\n        }\n      }\n    }\n\n    this._cancelPressDelayTimeout();\n  }\n\n  _activate(event) {\n    var _this$_config5 = this._config,\n        onPressChange = _this$_config5.onPressChange,\n        onPressStart = _this$_config5.onPressStart;\n    var touch = getTouchFromResponderEvent(event);\n    this._touchActivatePosition = {\n      pageX: touch.pageX,\n      pageY: touch.pageY\n    };\n\n    if (onPressStart != null) {\n      onPressStart(event);\n    }\n\n    if (onPressChange != null) {\n      onPressChange(true);\n    }\n  }\n\n  _deactivate(event) {\n    var _this$_config6 = this._config,\n        onPressChange = _this$_config6.onPressChange,\n        onPressEnd = _this$_config6.onPressEnd;\n\n    function end() {\n      if (onPressEnd != null) {\n        onPressEnd(event);\n      }\n\n      if (onPressChange != null) {\n        onPressChange(false);\n      }\n    }\n\n    var delayPressEnd = normalizeDelay(this._config.delayPressEnd);\n\n    if (delayPressEnd > 0) {\n      this._pressOutDelayTimeout = setTimeout(() => {\n        end();\n      }, delayPressEnd);\n    } else {\n      end();\n    }\n  }\n\n  _handleLongPress(event) {\n    if (this._touchState === RESPONDER_ACTIVE_PRESS_START || this._touchState === RESPONDER_ACTIVE_LONG_PRESS_START) {\n      this._receiveSignal(LONG_PRESS_DETECTED, event);\n    }\n  }\n\n  _cancelLongPressDelayTimeout() {\n    if (this._longPressDelayTimeout != null) {\n      clearTimeout(this._longPressDelayTimeout);\n      this._longPressDelayTimeout = null;\n    }\n  }\n\n  _cancelPressDelayTimeout() {\n    if (this._pressDelayTimeout != null) {\n      clearTimeout(this._pressDelayTimeout);\n      this._pressDelayTimeout = null;\n    }\n  }\n\n  _cancelPressOutDelayTimeout() {\n    if (this._pressOutDelayTimeout != null) {\n      clearTimeout(this._pressOutDelayTimeout);\n      this._pressOutDelayTimeout = null;\n    }\n  }\n\n}\n\nfunction normalizeDelay(delay, min, fallback) {\n  if (min === void 0) {\n    min = 0;\n  }\n\n  if (fallback === void 0) {\n    fallback = 0;\n  }\n\n  return Math.max(min, delay !== null && delay !== void 0 ? delay : fallback);\n}\n\nfunction getTouchFromResponderEvent(event) {\n  var _event$nativeEvent = event.nativeEvent,\n      changedTouches = _event$nativeEvent.changedTouches,\n      touches = _event$nativeEvent.touches;\n\n  if (touches != null && touches.length > 0) {\n    return touches[0];\n  }\n\n  if (changedTouches != null && changedTouches.length > 0) {\n    return changedTouches[0];\n  }\n\n  return event.nativeEvent;\n}"]},"metadata":{},"sourceType":"module"}